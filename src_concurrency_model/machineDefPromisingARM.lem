(*===============================================================================*)
(*                                                                               *)
(*                rmem executable model                                          *)
(*                =====================                                          *)
(*                                                                               *)
(*  This file is:                                                                *)
(*                                                                               *)
(*  Copyright Christopher Pulte, University of Cambridge 2017-2018               *)
(*  Copyright Shaked Flur, University of Cambridge            2017               *)
(*  Copyright Jon French, University of Cambridge             2018               *)
(*                                                                               *)
(*  All rights reserved.                                                         *)
(*                                                                               *)
(*  It is part of the rmem tool, distributed under the 2-clause BSD licence in   *)
(*  LICENCE.txt.                                                                 *)
(*                                                                               *)
(*===============================================================================*)

open import Relation
open import Pervasives_extra
open import MachineDefFreshIds
open import MachineDefUtils
open import Sail_impl_base
open import MachineDefTypes
open import MachineDefFragments
open import MachineDefEvents
open import MachineDefDebug
open import MachineDefThreadSubsystemUtils
open import MachineDefInstructionPredicates
(* open import MachineDefPOPStorageSubsystem *)
     import Map
open import MachineDefUI
     import ArmV8_embed_types
open ListMonad


type pts = promising_thread_state
type pss = promising_storage_state



(** Storage Subsystem *********************************************************)
(*  Total-order based *********************************************************)

(* initial state *)

let pssto_initial_state params threads iws = 
  let make_write i w = (w, List.length iws - i, Nothing) in
  PSSTO <| pssto_memory = List.mapi make_write iws;
           pssto_stopped_promising = false |>

(* NOTE: returns current time, not next timestamp *)
val pssto_view : pssto -> t
let pssto_view pss = 
  match pss.pssto_memory with
  | [] -> (0 : nat)
  | (w,t,_) :: _ -> t
end

let pssto_find_write pss weiid =
  List_extra.findNonPure (fun (w,_,_) -> w.weiid = weiid) pss.pssto_memory

let pssto_view_of_write pss id =
  let (_,t,_) = pssto_find_write pss id in t
  

(* read transition *)

let pssto_possible_read_writes pss (rr,t) =
  let addr_writes = [(w,t) | forall ((w,t,_) MEM pss.pssto_memory) 
                           | sub_footprint rr.r_addr w.w_addr] in
  let (after,before) = splitWhile (fun (w,wt) -> wt > t) addr_writes in
  let ws = match before with
  | w::ws -> w :: after
  | [] -> after
  end in
  let () = ensure (ws <> []) "no write to read from found" in
  ws

let pssto_receive_mem_satisfy_read_transition pss tl = 
  let (rr,t) = (fst tl.tl_label, ensure_timestamp (snd tl.tl_label)) in
  pssto_possible_read_writes pss (rr,t) >>= fun (w,t) ->
  let tl' = <| tl with tl_suppl = Just (Just (w, Timestamp t)) |> in
  return (T_trans (T_sync (T_Promising_mem_satisfy_read tl') Nothing))


(* write transition *)

let pssto_can_be_atomic pss w rf_weiid = 
  let before_w = tail (dropWhile (fun (w',_,_) -> w <> w') pss.pssto_memory) in
  let between = takeWhile (fun (w',_,_) -> w'.weiid <> rf_weiid) before_w in
  forall ((w',_,_) MEM between).
  (fst w'.w_addr <> fst w.w_addr || w'.w_thread = w.w_thread)

let pssto_can_store_xcl_succeed pss w rxinfo =
  match rxinfo with
  | Nothing -> true
  | Just (rf_weiid,r_addr) ->
     (fst w.w_addr <> r_addr) || (pssto_can_be_atomic pss w rf_weiid)
  end

let pssto_receive_propagate_write_transition pss tl = 
  let wd = fst tl.tl_label in
  let t = pssto_view pss in
  let memory = (wd.wd_w,t+1,Nothing) :: pss.pssto_memory in
  let pss = <| pss with pssto_memory = memory |> in
  guard (pssto_can_store_xcl_succeed pss wd.wd_w wd.wd_rexinfo) >>
  let c () = PSSTO pss in
  let tl' = <| tl with tl_suppl = Just (MWO_successful (Timestamp (t+1))) |> in
  return (T_trans (T_sync (T_Promising_propagate_write tl') (Just c)))


(* non-shared-write transition *)

(* Assumes w' has sub-footprint of w *)
let update_memory_write w w' = 
  let mrs = ensure_just (mrs_from_writes w.w_addr (complete_writes [w';w]))
              "PromisingARM: update_write failed" in
  <| w with w_value = Just mrs.mrs_value |>

let rec pssto_replace_write_aux w' acc rest = 
  match rest with
  | [] -> failwith "no matching write to replace found"
  | (w,t,mtid) :: rest ->
     if sub_footprint (w'.w_addr) (w.w_addr)
     then 
       let () = match mtid with
         | Just tid -> ensure (tid = w'.w_thread) "Multiple threads accessing shared memory"
         | Nothing -> () 
       end in
       (List.reverseAppend ((update_memory_write w w',t, Just w'.w_thread) :: acc) rest, t)
     else pssto_replace_write_aux w' ((w,t,mtid) :: acc) rest
  end

let pssto_replace_write w memory =
  pssto_replace_write_aux w [] memory

let pssto_receive_propagate_write_nonshared_transition pss tl = 
  let wd = tl.tl_label in
  let (memory,t) = pssto_replace_write wd.wd_w pss.pssto_memory in
  let tl' = <| tl with tl_suppl = Just (MWO_successful wd.wd_req_view) |> in
  let c () = PSSTO <| pss with pssto_memory = memory |> in
  return (T_trans (T_sync (T_Promising_propagate_write_nonshared tl') (Just c)))


(* fulfil transition *)

let pssto_receive_fulfil_promise_transition pss tl = 
  let wd = tl.tl_label in
  let required_view = ensure_timestamp (wd.wd_req_view) in
  let (w,t,_) = pssto_find_write pss wd.wd_w.weiid in
  guard (wd.wd_w = w && required_view < t) >>
  guard (pssto_can_store_xcl_succeed pss wd.wd_w wd.wd_rexinfo) >>
  let tl = <| tl with tl_suppl = Just (MWO_successful (Timestamp t)) |> in
  return (T_trans (T_sync (T_Promising_fulfil_promise tl) Nothing))


(* receive transitions *)

let pssto_receive_transitions pss = function
  | T_Promising_propagate_write tl ->
     pssto_receive_propagate_write_transition pss tl
  | T_Promising_propagate_write_nonshared tl ->
     pssto_receive_propagate_write_nonshared_transition pss tl
  | T_Promising_fulfil_promise tl ->
     pssto_receive_fulfil_promise_transition pss tl
  | T_Promising_mem_satisfy_read tl -> 
     pssto_receive_mem_satisfy_read_transition pss tl
  | T_Promising_mem_satisfy_read_nonshared tl ->
     pssto_receive_mem_satisfy_read_transition pss tl
  | _ -> failwith "unsupported promising_storage_subsystem request"
end


(* UI *)

let pssto_make_ui_state_1 ss' ss_trans = 
  PSSTO_UI
    <| ui_pssto_memory = unchanged3_list ss'.pssto_memory; 
       ui_pssto_stopped_promising = C2b_unchanged ss'.pssto_stopped_promising;
       ui_pssto_transitions = ss_trans |>

let pssto_make_ui_state_2 ss ss' ss_trans = 
  PSSTO_UI
    <| ui_pssto_memory = ui_list_diff3 ss.pssto_memory ss'.pssto_memory; 
       ui_pssto_stopped_promising = 
         ui_eq_diff2b ss.pssto_stopped_promising ss'.pssto_stopped_promising;
       ui_pssto_transitions = ss_trans |>


(* final state logging *)

let pssto_coherence pss =
  {(w,w') | forall (((w',_,_),(w,_,_)) IN list_to_rel (pss.pssto_memory))
          | w.w_addr = w'.w_addr}


let pssto_thread_memory_value_of_footprint s fp = 
  let writes = 
    List.map (fun (w,_,_) -> write_with_complete_slice w) s.pssto_memory in
  let mrs = ensure_just (mrs_from_writes fp writes)
              "promising_ss_thread_memory_value_of_footprints" in
  mrs.mrs_value


(* Partial-order based ********************************************************)

(* initial state *)

let psspo_initial_state params threads iws = 
  let addr_view = {(w.weiid, w'.w_addr) | forall (w MEM iws) (w' MEM iws) | true} in
  let order = list_to_rel (List.map (fun w -> w.weiid) (List.reverse iws)) in
  PSSPO <| psspo_writes = Set.fromList iws;
           psspo_order = order;
           psspo_addr_view = addr_view;
           psspo_stopped_promising = false |>

(* auxiliary functions *)

let psspo_ids_to_writes pss ids =
  {w | forall (w IN pss.psspo_writes) | w.weiid IN ids}

let psspo_id_to_write pss id = 
  Set_extra.choose (psspo_ids_to_writes pss (Set.singleton id))

let psspo_writes_to_ids writes = 
  Set.map (fun w -> w.weiid) writes

let downclosure_f f pss w = 
  {f w' | forall (w' IN pss.psspo_writes) 
        | w'.weiid = w || (w'.weiid,w) IN pss.psspo_order}

let inline downclosure = downclosure_f id

let psspo_view_of_write pss w = 
  WI (psspo_writes_to_ids (downclosure pss w))

let psspo_find_write pss id = 
  let w = psspo_id_to_write pss id in
  let v = psspo_view_of_write pss id in
  (w, v)


let normalise_addr_view pss =
  let addr_view = 
    bigunionMap (fun (w,addr) -> downclosure_f (fun w' -> (w'.weiid,addr)) pss w)
      pss.psspo_addr_view
  in
  <| pss with psspo_addr_view = addr_view |>

val psspo_view : psspo -> write_ids
let psspo_view pss = WI {w.weiid | forall (w IN pss.psspo_writes) | true}


(* read transition *)

let psspo_possible_read_writes pss rr writes_in_view =
  Set_extra.toList
    {w | forall (w IN pss.psspo_writes) 
       | sub_footprint rr.r_addr w.w_addr &&
         forall (w' IN writes_in_view).
         (sub_footprint rr.r_addr w'.w_addr --> 
         (w.weiid,w'.weiid) NIN pss.psspo_order) }


(* Add edges from the dependencies (writes_seen) to the non-read
   writes. Also, add "future edges": from writes_seen to all future
   writes to the address of the read and the write. *)
let psspo_constrain_after_read pss rr wids_seen w =
  let not_read = {w'.weiid | forall (w' IN pss.psspo_writes) 
                           | sub_footprint rr.r_addr w'.w_addr &&
                             (w.weiid,w'.weiid) IN pss.psspo_order } in
  let new_order_edges = cross wids_seen not_read in
  let new_addr_view_edges = cross wids_seen {w.w_addr} in

  if Set.null new_order_edges && Set.null new_addr_view_edges
  then Nothing else
    let order = transitiveClosure (pss.psspo_order union new_order_edges) in
    let addr_view = pss.psspo_addr_view union new_addr_view_edges in
    let pss = <| pss with psspo_order = order; psspo_addr_view = addr_view |> in
    Just (normalise_addr_view pss)

let psspo_receive_mem_satisfy_read_transition pss tl = 
  let (rr, WI v) = (fst tl.tl_label, ensure_write_ids (snd tl.tl_label)) in
  let writes_seen = bigunionMap (downclosure pss) v in
  psspo_possible_read_writes pss rr writes_seen >>= fun w ->
  let wids_seen = psspo_writes_to_ids writes_seen in
  let w_seen = downclosure_f (fun w -> w.weiid) pss w.weiid in
  let v' = Write_Ids (WI w_seen) in
  match psspo_constrain_after_read pss rr (wids_seen union w_seen) w with
  | Just pss -> 
     let c () = PSSPO pss in
     let tl' = <| tl with tl_suppl = Just (Just (w, v')) |> in
     return (T_trans (T_sync (T_Promising_mem_satisfy_read tl') (Just c)))
  | Nothing -> 
     let tl' = <| tl with tl_suppl = Just (Just (w, v')) |> in
     return (T_trans (T_sync (T_Promising_mem_satisfy_read tl') Nothing))
  end

let psspo_receive_mem_satisfy_read_nonshared_transition pss tl = 
  let (rr, WI v) = (fst tl.tl_label, ensure_write_ids (snd tl.tl_label)) in
  let writes_seen = bigunionMap (downclosure pss) v in
  psspo_possible_read_writes pss rr writes_seen >>= fun w ->
  let w_seen = downclosure_f (fun w -> w.weiid) pss w.weiid in
  let v' = Write_Ids (WI w_seen) in
  let tl' = <| tl with tl_suppl = Just (Just (w, v')) |> in
  return (T_trans (T_sync (T_Promising_mem_satisfy_read tl') Nothing))


(* write transition *)

let psspo_can_be_atomic pss w rf_weiid = 
  forall (w' IN pss.psspo_writes).
  ((rf_weiid,w'.weiid) IN pss.psspo_order && (w'.weiid,w.weiid) IN pss.psspo_order) -->
  (fst w'.w_addr <> fst w.w_addr || w'.w_thread = w.w_thread)

let psspo_can_store_xcl_succeed pss w rxinfo =
  match rxinfo with
  | Nothing -> true
  | Just (rf_weiid,r_addr) ->
     (fst w.w_addr <> r_addr) || (psspo_can_be_atomic pss w rf_weiid)
  end

let psspo_receive_propagate_write_transition pss tl = 
  let wd = fst tl.tl_label in 
  let (WI req_view) = ensure_write_ids wd.wd_req_view in
  let writes = Set.insert wd.wd_w pss.psspo_writes in
  let order =
    transitiveClosure
      (pss.psspo_order union
      {(w.weiid,wd.wd_w.weiid) | forall (w IN pss.psspo_writes) 
                               | w.weiid IN req_view || 
                                 non_empty_intersection w.w_addr wd.wd_w.w_addr}
      union
      {(w,wd.wd_w.weiid) | forall ((w,addr) IN pss.psspo_addr_view) 
                         | non_empty_intersection addr wd.wd_w.w_addr} )
  in
  let pss = <| pss with psspo_writes = writes; psspo_order = order |> in
  let pss = normalise_addr_view pss in
  guard (psspo_can_store_xcl_succeed pss wd.wd_w wd.wd_rexinfo) >>
  let w_view = psspo_view_of_write pss wd.wd_w.weiid in
  let c () = PSSPO pss in
  let tl' = <| tl with tl_suppl = Just (MWO_successful (Write_Ids w_view)) |> in
  return (T_trans (T_sync (T_Promising_propagate_write tl') (Just c)))


(* fulfil transition *)

let psspo_receive_fulfil_promise_transition pss tl = 
  let wd = tl.tl_label in
  let required_view = ensure_write_ids wd.wd_req_view in
  let (w, ((WI ids) as v)) = psspo_find_write pss wd.wd_w.weiid in
  guard (wd.wd_w = w && le required_view (WI (ids \ {w.weiid}))) >>
  guard (psspo_can_store_xcl_succeed pss wd.wd_w wd.wd_rexinfo) >>
  let tl = <| tl with tl_suppl = Just (MWO_successful (Write_Ids v)) |> in
  return (T_trans (T_sync (T_Promising_fulfil_promise tl) Nothing))


(* non-shared-write transition *)

let psspo_receive_propagate_write_nonshared_transition pss tl = 
  let wd = tl.tl_label in
  let w = Set_extra.choose {w | forall (w IN pss.psspo_writes)
                              | sub_footprint (wd.wd_w.w_addr) (w.w_addr)} in
  let w' = update_memory_write w wd.wd_w in
  let writes = Set.insert w' (Set.delete w pss.psspo_writes) in
  let pss = <| pss with psspo_writes = writes |> in
  let tl' = <| tl with tl_suppl = Just (MWO_successful wd.wd_req_view) |> in
  let c () = PSSPO pss in
  return (T_trans (T_sync (T_Promising_propagate_write_nonshared tl') (Just c)))


(* receive transitions *)

let psspo_receive_transitions pss = function
  | T_Promising_propagate_write tl ->
     psspo_receive_propagate_write_transition pss tl
  | T_Promising_fulfil_promise tl ->
     psspo_receive_fulfil_promise_transition pss tl
  | T_Promising_mem_satisfy_read tl -> 
     psspo_receive_mem_satisfy_read_transition pss tl
  | T_Promising_mem_satisfy_read_nonshared tl -> 
     psspo_receive_mem_satisfy_read_nonshared_transition pss tl
  | T_Promising_propagate_write_nonshared tl ->
     psspo_receive_propagate_write_nonshared_transition pss tl
  | _ -> failwith "unsupported promising_storage_subsystem request"
end


(* UI *)

let psspo_make_ui_state_1 ss' ss_trans = 
  PSSPO_UI
    <| ui_psspo_writes = unchanged3_set ss'.psspo_writes; 
       ui_psspo_write_order = unchanged3_set ss'.psspo_order;
       ui_psspo_addr_view = unchanged3_set ss'.psspo_addr_view;
       ui_psspo_stopped_promising = C2b_unchanged ss'.psspo_stopped_promising;
       ui_psspo_transitions = ss_trans |>

let psspo_make_ui_state_2 ss ss' ss_trans = 
  PSSPO_UI
    <| ui_psspo_writes = ui_set_diff3 ss.psspo_writes ss'.psspo_writes; 
       ui_psspo_write_order = 
         pop_diff_coherence ss.psspo_order ss'.psspo_order;
       ui_psspo_addr_view = ui_set_diff3 ss.psspo_addr_view ss'.psspo_addr_view;
       ui_psspo_stopped_promising = 
         ui_eq_diff2b ss.psspo_stopped_promising ss'.psspo_stopped_promising;
       ui_psspo_transitions = ss_trans |>

(* final state logging *)

let psspo_coherence pss = 
  Set.mapMaybe 
    (fun (w,w') -> 
      let w = psspo_id_to_write pss w in
      let w' = psspo_id_to_write pss w' in
      if w.w_addr = w'.w_addr then Just (w,w') else Nothing)
    pss.psspo_order



(* adapting code from POP *)
let rec psspo_thread_memory_value_of_footprint_aux acc writes order fp = 
  if Set.null writes
  then (ensure_just (mrs_from_writes fp acc)
          "promising_ss_thread_memory_value_of_footprints").mrs_value
  else
    let minimal = 
      Set_extra.choose 
        { w | forall (w IN writes) 
            | not (exists (w' IN writes). (w'.weiid,w.weiid) IN order)} 
    in
    let acc = (write_with_complete_slice minimal) :: acc in
    let writes = writes \ {minimal} in
    psspo_thread_memory_value_of_footprint_aux acc writes order fp

let psspo_thread_memory_value_of_footprint s fp = 
  let writes_to_addr =
    {w | forall (w IN s.psspo_writes) | non_empty_intersection w.w_addr fp} in
  psspo_thread_memory_value_of_footprint_aux [] writes_to_addr s.psspo_order fp



(*  Unifying storage models****************************************************)

let stopped_promising = function
  | PSSTO s -> s.pssto_stopped_promising
  | PSSPO s -> s.psspo_stopped_promising
end

let set_stopped_promising = function
  | PSSTO s -> PSSTO <| s with pssto_stopped_promising = true |>
  | PSSPO s -> PSSPO <| s with psspo_stopped_promising = true |>
end

let promising_ss_initial_state params threads iws =
  if params.t.promising_partial_order
  then psspo_initial_state params threads iws
  else pssto_initial_state params threads iws

let inline pss_view = function
  | PSSTO pss -> Timestamp (pssto_view pss)
  | PSSPO pss -> Write_Ids (psspo_view pss)
end

(* val pss_find_write : pss -> w_eiid -> write * view
 * let inline pss_find_write pss w =
 *   match pss with
 *   | PSSTO pss -> 
 *      let (w,v) = pssto_find_write pss w in
 *      (w, Timestamp v)
 *   | PSSPO pss -> 
 *      let (w,v) = psspo_find_write pss w in
 *      (w,Write_Ids v)
 * end *)


val promising_ss_receive_transitions : 
  forall 'ts. pss -> thread_sync_label 'ts -> list (trans 'ts pss)
let inline promising_ss_receive_transitions = function
  | PSSTO pss -> pssto_receive_transitions pss
  | PSSPO pss -> psspo_receive_transitions pss
end

let make_ui_promising_storage_state (ss: maybe pss) (ss': pss)
      (transitions: list (ui_trans 'ts 'ss))
    : ui_storage_subsystem_state 'ts 'ss
  =
  let transitions = List.filter (comb is_storage_transition snd) transitions in
  match (ss,ss') with
  | (Nothing, PSSTO ss') ->
     Promising_UI_storage (pssto_make_ui_state_1 ss' transitions)
  | (Just (PSSTO ss), PSSTO ss') ->
     Promising_UI_storage (pssto_make_ui_state_2 ss ss' transitions)
  | (Nothing, PSSPO ss') ->
     Promising_UI_storage (psspo_make_ui_state_1 ss' transitions)
  | (Just (PSSPO ss), PSSPO ss') ->
     Promising_UI_storage (psspo_make_ui_state_2 ss ss' transitions)
  | _ -> fail
  end

let promising_ss_enumerate_transitions params s = 
  guard (params.ss.promise_first && not (stopped_promising s)) >>
  let c () = set_stopped_promising s in
  return (SS_trans (SS_only SS_Promising_stop_promising c))
  
let promising_ss_is_final_state params s = 
  params.promise_first --> (stopped_promising s)


let promising_ss_thread_memory_value_of_footprint _ s _ fp = 
  match s with
  | PSSTO s -> pssto_thread_memory_value_of_footprint s fp
  | PSSPO s -> psspo_thread_memory_value_of_footprint s fp
  end

let promising_ss_coherence _ = function
  | PSSTO s -> pssto_coherence s
  | PSSPO s -> psspo_coherence s
end

val promising_storage : storageSubsystem pss
let promising_storage = 
  <| ss_thread_memory_value_of_footprint = 
       promising_ss_thread_memory_value_of_footprint;
     ss_initial_state          = promising_ss_initial_state;
     ss_is_final_state         = promising_ss_is_final_state;
     ss_coherence              = promising_ss_coherence;
     ss_clean_reads = fun _ _ _ _ _ -> Nothing;
     ss_stopped_promising = fun s -> stopped_promising s;
  |>


(** Thread Subsystem **********************************************************)
(*  Auxiliaries ***************************************************************)

let in_shared_memory params fp =
  match params.shared_memory with
  | Just sm -> exists (fp' IN sm). sub_footprint fp fp'
  | Nothing -> true
  end

let is_RISC params =
  match params.t.thread_isa_info.ism with
  | RISCV_ism -> true
  | _ -> false
  end

let findBot x m = Map.findWithDefault x bot m

let reg r s =
  match Map.lookup r s.reg with
  | Just v -> v
  | Nothing -> register_state_zero s.regdata s.tid r
  end
let vReg r s = findBot r s.vReg
let vCoh addr s = findBot addr s.vCoh
let vRm s = s.vRm
let vRp s = s.vRp
let vWm s = s.vWm
let vWp s = s.vWp
let vCAP s = s.vCAP
let vRel s = s.vRel
let fwd_bank addr s = Map.lookup addr s.fwd_bank
let xcl_bank s = s.xcl_bank
let promises s = s.promises
let emptypromises' = function
  | PTSTO s -> Set.null (promises s)
  | PTSPO s -> Set.null (promises s)
end
let prog s     = s.prog
let initAddr s = s.initAddr
let initAddr' = function PTSTO s -> initAddr s | PTSPO s -> initAddr s end
let initRegS' = function PTSTO s -> s.initRegS | PTSPO s -> s.initRegS end
let retAddr s  = s.retAddr
let retAddr' = function PTSTO s -> retAddr s | PTSPO s -> retAddr s end
let tid s      = s.tid
let tid' = function PTSTO s -> tid s | PTSPO s -> tid s end
let ids s      = s.ids
let regdata r s  = ensure_just (reg_from_data s.regdata r) (show r)
let instrs s   = s.instrs
let instrs' = function PTSTO s -> instrs s | PTSPO s -> instrs s end
let set_reg r x s = <| s with reg = Map.insert r x s.reg |>
let inline set_reg' r x = function 
  | PTSTO s -> PTSTO (set_reg r x s)
  | PTSPO s -> PTSPO (set_reg r x s) 
end
let set_vReg r t s = <| s with vReg = Map.insert r t s.vReg |>
let inc_vCoh addr t s = 
  let t' = Map.findWithDefault addr bot s.vCoh in
  <| s with vCoh = Map.insert addr (join t t') s.vCoh |>
let inc_vRm t s = <| s with vRm = join t s.vRm |>
let inc_vRp t s = <| s with vRp = join t s.vRp |>
let inc_vWm t s = <| s with vWm = join t s.vWm |>
let inc_vWp t s = <| s with vWp = join t s.vWp |>
let inc_vRel t s = <| s with vRel = join t s.vRel |>
let inc_vCAP t s = <| s with vCAP = join t s.vCAP |>
let set_fwd_bank addr (t,wx,fwdt) s = 
  <| s with fwd_bank = Map.insert addr (t,wx,fwdt) s.fwd_bank |>
let set_xcl_bank x s = <| s with xcl_bank = x |>
let set_initAddr x s = <| s with initAddr = x |>
let inline set_initAddr' x = function 
  | PTSTO s -> PTSTO (set_initAddr x s)
  | PTSPO s -> PTSPO (set_initAddr x s)
end
let add_promise x s = <| s with promises = Set.insert x s.promises |>
val add_promise' : w_eiid * view * address -> pts -> pts
let add_promise' (wid,v,addr) s = match (v,s) with
  | (Timestamp x, PTSTO s) -> PTSTO (add_promise (wid,x,addr) s)
  | (Write_Ids x, PTSPO s) -> PTSPO (add_promise (wid,x,addr) s)
  | _ -> fail
end
let remove_promise wid s =
  <| s with promises = Set.filter (fun (w,_,_) -> w <> wid) s.promises |>
let remove_promise' wid = function
  | PTSTO s -> PTSTO (remove_promise wid s)
  | PTSPO s -> PTSPO (remove_promise wid s)
end
let empty_promises' = function
  | PTSTO s -> Set.null s.promises
  | PTSPO s -> Set.null s.promises
end
let set_ids x s    = <| s with ids = x |>
let set_instrs x s  = <| s with instrs = x |>

let gen_fresh_wid addr s = 
  let addr = natFromInteger (integer_of_address addr) in
  let n = findWithDefault addr 0 s.wids in
  let next = n+1 in
  let id = ((s.tid,addr),n) in
  let wids = Map.insert addr next s.wids in
  let s = <| s with wids = wids |> in
  (s,id)



let inline ifA (c : bool) (a : 'x -> 'x) (s : 'x) = 
  if c then a s else s


let ensure_done_outcome (o,_) =
  match o with Done a -> a | _ -> fail end
let ensure_barrier_outcome (o,_) =
  match o with Barrier bk o -> (bk,o) | _ -> fail end
let ensure_write_ea_outcome (o,_) =
  match o with Write_ea descr o -> (descr,o) | _ -> fail end
let ensure_write_memv_outcome (o,_) =
  match o with Write_memv memv c -> (memv,c) | _ -> fail end
let ensure_read_mem_outcome (o,_) =
  match o with Read_mem descr c -> (descr,c) | _ -> fail end
let ensure_excl_res_outcome (o,_) =
  match o with Excl_res c -> c | _ -> fail end
let ensure_write_reg_outcome (o,_) =
  match o with Write_reg descr o -> (descr,o) | _ -> fail end
let ensure_read_reg_outcome (o,_) =
  match o with Read_reg descr o -> (descr,o) | _ -> fail end
let ensure_mwo_successful = 
  function MWO_successful a -> a | _ -> fail end


let make_tc s = make_thread_cont_res Set.empty Set.empty (toPTS s)
let make_tc' s = make_thread_cont_res Set.empty Set.empty s
let addr_of_addr_lifted a = 
  ensure_just (address_of_address_lifted a) "fail" 

(*** Thread Subsystem **********************************************************)

let promising_find_instruction
    (p : list instruction_instance -> instruction_instance -> bool) 
    (s : pts)
  : maybe (list instruction_instance * instruction_instance) = 
  let aux : list (maybe (list instruction_instance * instruction_instance)) =
    mapWithContext
      (fun prefix instr suffix ->
        if p prefix instr then Just (prefix,instr) else Nothing)
      (List.reverse (instrs' s)) in
  let aux = List.mapMaybe id aux in
  index aux 0


let promising_registers_final_state_aux s = 
  List.map (fun (rbn,_) -> (rbn, Just (reg rbn s))) s.regdata

let inline promising_registers_final_state = function
  | PTSTO s -> promising_registers_final_state_aux s
  | PTSPO s -> promising_registers_final_state_aux s
  end

let promising_update_initial_register_state t updates = 
  List.foldl (fun s (x,y) -> set_reg' x y s) t updates

let promising_update_initial_fetch_address params (t : pts) addr = 
  let cia_reg = params.thread_isa_info.cia_reg in
  let rv = register_value_of_address addr (direction_of_reg_name cia_reg) in
  t $> set_reg' (register_base_name cia_reg) rv 
    $> set_initAddr' (Just addr) 


let inline dummy_ioid tid : ioid = (tid,0)
let inline dummy_eiid tid : eiid = (dummy_ioid tid,0)


let error_make_readwrite_events ii ((addr,sz) : footprint) =
  (show ii.instance_ioid) ^ ". addr=" ^ show addr ^  " size=" ^ show sz

let make_write_events params s ii (wk,addr,sz,memv) =
  let tid = tid s in
  let (write_addresses, _) =
    params.t.thread_isa_info.make_empty_write_events tid ii (addr,sz) wk in
  let (s,wid) = gen_fresh_wid addr s in
  let writes = MachineDefEvents.set_write_values memv write_addresses [] in
  let write = ensure_singleton writes
                "no/multiple write events generated for store" in
  let write = <| write with w_ioid = dummy_ioid tid; weiid = wid |> in
  (s,write)

let record_write ii w = 
  let subwrites = 
    <| sw_addr = Just w.w_addr;
       sw_potential_write_addresses = [];
       sw_potential_writes = [];
       sw_propagated_writes = [w];
       sw_committed = true |> 
  in
  <| ii with subwrites = subwrites |>


let make_read_events params tid ii (rk,addr,sz) = 
  let (read_requests, id_state') =
    params.t.thread_isa_info.make_read_request_events tid ii (addr, sz) rk in
  let rrs_and_unsat_slices =
    [(rr, [complete_slice rr.r_addr]) | forall (rr MEM read_requests) | true] in
  let (rr,unsat_slices) =
    ensure_singleton rrs_and_unsat_slices
      "no/multiple write events generated for load" in
  let ii = <| ii with instance_id_state = id_state'|> in
  (ii,rr)

let do_read ii rr w =
  let mrs = possible_mrs_for_read rr.r_addr [write_with_complete_slice w] in
  let subreads =
    <| sr_addr = Just rr.r_addr;
       sr_requested = [];
       sr_assembled_value = Just mrs.mrs_value;
       sr_writes_read_from = [(rr,mrs.mrs_writes_read_from)];
       sr_unsat_slices = [(rr,[])];
    |>
  in
  (<| ii with subreads = subreads |>,mrs.mrs_value)


let reg_value r s = 
  let rbn = register_base_name r in
  let (v,base_reg) = (reg rbn s, regdata rbn s) in 
  let (left,found) =
    match_maybe_value_fragment
      [slice_of_reg_name r] (slice_of_reg_name base_reg, Just v.rv_bits) in
  let () = ensure (null left) "fail" in
  ensure_just (reassemble_register_value r found) "fail"

let update_reg_value r v' s =
  let rbn = register_base_name r in
  let v = reg rbn s in
  let base_reg = regdata rbn s in
  let (left,found) = 
    match_maybe_value_fragments
      [slice_of_reg_name base_reg]
      [(slice_of_reg_name r, Just v'.rv_bits);
       (slice_of_reg_name base_reg, Just v.rv_bits)]
      []
  in
  let () = ensure (null left) "fail" in
  let v'' = ensure_just (reassemble_register_value base_reg found) "fail" in
  set_reg rbn v'' s

(* these do not handle mixed-size register accesses *)
let read_reg (s,ii,view,o) r = 
  let rbn = register_base_name r in
  let (v,view') = (reg_value r s, vReg rbn s) in
  let ii = <| ii with reg_reads = (r,[],v) :: ii.reg_reads |> in
  (s,ii,join view view',o v)

let write_reg (s,ii,view,o) (r,v,rview) = 
  let rbn = register_base_name r in
  let ii = <| ii with reg_writes = (r,([],v)) :: ii.reg_writes |> in
  let s = s $> update_reg_value r v
            $> set_vReg rbn rview in
  (s,ii,view,o)


let promising_initial_thread_state_aux
    (params : thread_params)
    (tid : thread_id)
    (prog : address -> fetch_and_decode_outcome)
    (ret_addr : address)
    (rd : registerdata)
    (ird : list (reg_base_name * register_value))
    (irv : reg_base_name -> register_value)
    (addr : maybe address)
    (iws : list write)
    (_fake_view_parameter_for_type_system : 'v)
  : (pts' 'v) =
  (* replicating what promising_ss_initial_state does *)
  let ws = List.map (fun w -> (fst w.w_addr,bot)) iws in
  let vCoh = Map.fromList ws in
  let reg = List.foldl (fun m (rbn,v) -> Map.insert rbn v m) Map.empty ird in
  let reg = match addr with
    | Just addr ->
       let cia_reg = params.thread_isa_info.cia_reg in
       let rv = register_value_of_address addr (direction_of_reg_name cia_reg) in
       Map.insert (register_base_name cia_reg) rv reg
    | Nothing -> reg
    end in
  let tReg = List.foldl (fun m (n,_) -> Map.insert n bot m) Map.empty ird in

  let s = <| reg = reg
           ; vCoh = vCoh
           ; vReg = tReg
           ; vRm  = bot
           ; vRp  = bot
           ; vWm  = bot
           ; vWp  = bot
           ; vCAP = bot
           ; vRel = bot
           ; fwd_bank = Map.empty
           ; xcl_bank = Nothing
           ; promises = Set.empty
           ; prog     = prog
           ; retAddr  = ret_addr
           ; initAddr = addr
           ; tid      = tid
           ; ids      = MachineDefFreshIds.initial_id_state tid
           ; wids     = Map.empty
           ; regdata  = rd
           ; instrs   = []
           ; initRegS = irv
           |>
  in
  List.foldl (fun s (r,v) -> update_reg_value r v s)
    s params.thread_isa_info.fixed_pseudo_registers

let promising_initial_thread_state
      params tid prog ret_addr rd ird irv addr iws = 
  if params.t.promising_partial_order
  then PTSPO (promising_initial_thread_state_aux
                params.t tid prog ret_addr rd ird irv addr iws bot)
  else PTSTO (promising_initial_thread_state_aux
                params.t tid prog ret_addr rd ird irv addr iws bot)


let rec do_internal_steps (s,ii,view,o) = 
  match fst o with
  | Internal _ o -> do_internal_steps (s,ii,view,o)
  | _ -> (s,ii,view,o)
end

let rec do_local_effs (s,ii,view,o) = 
  match fst o with
  | Done () ->           (s,ii,view,o)
  | Read_mem _ _ ->      (s,ii,view,o)
  | Write_ea _ _ ->      (s,ii,view,o)
  | Write_memv _ _ ->    (s,ii,view,o)
  | Barrier _ _ ->       (s,ii,view,o)
  | Excl_res _ ->        (s,ii,view,o)
  | Read_reg r o ->      do_local_effs (read_reg (s,ii,view,o) r)
  | Write_reg (r,v) o -> do_local_effs (write_reg (s,ii,view,o) (r,v,view))
  | Internal _ o ->      do_local_effs (s,ii,view,o)
  | Escape Nothing ->    failwith ("escape Nothing")
  | Escape (Just err) -> failwith ("escape " ^ err)
  | Error err ->         failwith ("unhandled Error " ^ err)
  | Fail (Just msg) ->   failwith ("Sail assertion: Fail '" ^ msg ^ "'")
  | Fail Nothing ->      failwith ("Sail assertion: Fail")
  | Footprint o ->       failwith "footprint recalculation not supported"
end

let write_nia_arm params (s,ii,view,o) = 
  let nia_reg = params.t.thread_isa_info.nia_reg in
  let nia_rbn = register_base_name nia_reg in
  if isJust (List.lookup nia_reg ii.reg_writes)
  then (s,ii,view,o)
  else
    let nia_v = add_address_nat ii.program_loc 4 in
    let v = register_value_of_address nia_v (direction_of_reg_name nia_reg) in
    let s = set_reg nia_rbn v s in
    let s = set_vReg nia_rbn bot s in
    (s,ii,view,o)

let write_nia_riscv params (s,ii,view,o) = 
  let cia_reg = params.t.thread_isa_info.cia_reg in
  let cia_rbn = register_base_name cia_reg in
  let nia_reg = params.t.thread_isa_info.nia_reg in
  let nia_rbn = register_base_name nia_reg in
  let s = 
    if isJust (List.lookup nia_reg ii.reg_writes) then s
    else
      let nia_v = add_address_nat ii.program_loc 4 in
      let v = register_value_of_address nia_v (direction_of_reg_name nia_reg) in
      let s = set_reg nia_rbn v s in
      let s = set_vReg nia_rbn bot s in
      s
  in
  let nia_v = reg nia_rbn s in
  let s = set_reg cia_rbn nia_v s in
  let s = set_vReg cia_rbn bot s in
  (s,ii,view,o)

let write_nia params (s,ii,view,o) = 
  match params.t.thread_isa_info.ism with
  | AARCH64_ism _ -> write_nia_arm params (s,ii,view,o)
  | RISCV_ism -> write_nia_riscv params (s,ii,view,o)
  | _ -> fail
  end

let finish_instruction params (s,ii,view,o) = 
  let () = ensure_done_outcome o in
  let ii = <| ii with finished = true |> in
  let (s,ii,view,o) = write_nia params (s,ii,view,o) in
  let s = set_instrs (ii :: (instrs s)) s in
  (s,ii)

val make_plain_transition :
  forall 'v. View 'v => 
  pts' 'v * instruction_instance ->
  list (thread_trans pts)
let make_plain_transition (s,ii) =
  let c () = make_tc s in
  let tl = T_finish ii.program_loc ii.instruction in
  return (T_only (make_label' (tid s) ii.instance_ioid tl c))
    
type iie_state 'v = pts' 'v * instruction_instance * 'v * outcome_S
type instr_runner 'v = model_params -> iie_state 'v -> list (thread_trans pts)
type instr_runner_s 'v = model_params -> iie_state 'v -> thread_trans pts

val run_barrier_instruction : forall 'v. View 'v => instr_runner 'v
let run_barrier_instruction params (s,ii,view,o) = 
  let (s,ii,view,o) = do_local_effs (s,ii,view,o) in
  let (bk,o) = ensure_barrier_outcome o in
  let (Rp,Wp) = match bk with
    | Barrier_DMB ->    ([vRm s;vWm s], [vRm s;vWm s])
    | Barrier_DSB ->    ([vRm s;vWm s], [vRm s;vWm s])
    | Barrier_DMB_LD -> ([vRm s]      , [vRm s])
    | Barrier_DSB_LD -> ([vRm s]      , [vRm s])
    | Barrier_DMB_ST -> ([]           , [vWm s])
    | Barrier_DSB_ST -> ([]           , [vWm s])
    | Barrier_ISB ->    ([vCAP s]     , [vCAP s])

    | Barrier_RISCV_rw_rw -> ([vRm s;vWm s], [vRm s;vWm s])
    | Barrier_RISCV_r_rw -> ([vRm s], [vRm s])
    | Barrier_RISCV_w_rw -> ([vWm s], [vWm s])
    | Barrier_RISCV_rw_r -> ([vRm s;vWm s], [])
    | Barrier_RISCV_r_r -> ([vRm s], [])
    | Barrier_RISCV_w_r -> ([vWm s], [])
    | Barrier_RISCV_rw_w -> ([], [vRm s;vWm s])
    | Barrier_RISCV_r_w -> ([], [vRm s])
    | Barrier_RISCV_w_w -> ([], [vWm s])
    | Barrier_RISCV_tso -> ([vRm s], [vRm s;vWm s])
    | Barrier_RISCV_i -> ([]     , [])

    | _ -> failwith ("cannot handle this barrier: " ^ show bk)
    end in
  let s = s $> inc_vRp (joinS Rp) $> inc_vWp (joinS Wp) in
  let (s,ii,view,o) = do_local_effs (s,ii,view,o) in
  make_plain_transition (finish_instruction params (s,ii,view,o))

val run_branch_instruction : forall 'v. View 'v => instr_runner 'v
let run_branch_instruction params (s,ii,view,o) = 
  let ii = <| ii with instruction_kind = IK_branch |> in
  let (s,ii,view,o) = do_local_effs (s,ii,view,o) in
  let s = inc_vCAP view s in
  make_plain_transition (finish_instruction params (s,ii,view,o))

val run_plain_instruction : forall 'v. View 'v => instr_runner 'v
let run_plain_instruction params (s,ii,view,o) =
  let ii = <| ii with instruction_kind = IK_simple |> in
  let (s,ii,view,o) = do_local_effs (s,ii,view,o) in
  make_plain_transition (finish_instruction params (s,ii,view,o))

val run_failed_store_exclusive_instruction : forall 'v. View 'v => instr_runner_s 'v
let run_failed_store_exclusive_instruction params (s,ii,_view,o) = 
  let view = bot in (* revisit to check if still good *)
  let s = set_xcl_bank Nothing s in
  let (s,ii,view,o) = do_local_effs (s,ii,view,o) in
  let (s,ii) = finish_instruction params (s,ii,view,o) in
  let c () = make_tc s in
  let tl = T_failed_store_excl in
  T_only (make_label' (tid s) ii.instance_ioid tl c)

val run_amo_instruction : forall 'v. View 'v => instr_runner 'v
let run_amo_instruction params (s,ii,view,o) = 
  failwith "AMO instruction not supported yet."

val run_load_instruction : forall 'v. View 'v => instr_runner 'v
let run_load_instruction params (s,ii,view,o) = 
  let (s,ii,addr_view,o) = do_local_effs (s,ii,view,o) in
  let ((rk,addr,sz),c) = ensure_read_mem_outcome o in
  let addr = addr_of_addr_lifted addr in
  let (ii,rr) = make_read_events params (tid s) ii (rk,addr,sz) in
  let pre_view =
    joinS [addr_view;
           vRp s;
           ifV (is_strong_acquire_R rk) (vRel s);
           ifV (is_release_R rk) (vRm s);
           ifV (is_release_R rk) (vWm s)
      ] in
  let c result = 
    let (w,v) = ensure_just result "read from unmapped memory" in
    let t = to_v v in
    let (ii,mv) = do_read ii rr w in
    let ii = <| ii with instruction_kind = IK_mem_read rk |> in
    let rf_view = match fwd_bank addr s with
      | Nothing -> t
      | Just (fwd_weiid,wx,fwd_view) -> 
         if fwd_weiid = w.weiid && ((is_RISC params || is_acquire_R rk) --> not wx)
         then fwd_view else t
    end in 
    let post_view = join pre_view rf_view in
    let s = 
      s $> inc_vCoh addr post_view
        $> inc_vRm post_view
        $> inc_vCAP addr_view
        $> ifA (is_acquire_R rk) (inc_vRp post_view)
        $> ifA (is_acquire_R rk) (inc_vWp post_view)
        $> ifA (is_strong_release_R rk) (inc_vRel post_view)
        $> ifA (is_exclusive_R rk) (set_xcl_bank (Just ((w.weiid,addr),post_view)))
    in
    let (s,ii,view,o) = do_local_effs (s,ii,post_view,c mv) in
    make_tc (fst (finish_instruction params (s,ii,view,o)))
  in
  let tkind = if in_shared_memory params (addr,sz)
              then T_Promising_mem_satisfy_read
              else T_Promising_mem_satisfy_read_nonshared in
  let label = make_label' (tid s) ii.instance_ioid (rr, to_view (join (vCoh addr s) pre_view)) c in
  return (T_sync (tkind label) ())


(* see also run_store_exclusive_instruction *)
val run_store_instruction : 
  forall 'v. View 'v, SetType 'v => 
    (Maybe.maybe ((w_eiid * Sail_impl_base.address) * 'v)) ->
    instr_runner 'v
let run_store_instruction xinfo params (s,ii,view,o) = 
  let (s,ii,addr_view,o) = do_local_effs (s,ii,view,o) in
  let ((wk,addr,sz),o) = ensure_write_ea_outcome o in
  let addr = addr_of_addr_lifted addr in
  let _ = natFromInteger (integer_of_address addr) in
  let (s,ii,addr_data_view,o) = do_local_effs (s,ii,addr_view,o) in
  let (mv,c) = ensure_write_memv_outcome o in
  let (s,w) = make_write_events params s ii (wk,addr,sz,mv) in
  let pre_view = 
    joinS [addr_data_view; 
           vCAP s; 
           vWp s;
           ifV (is_release_W wk) (vRm s);
           ifV (is_release_W wk) (vWm s);
           ifV (is_strong_acquire_W wk) (vRel s);
           ifV (is_exclusive_W wk && is_RISC params) 
             (mV (Maybe.map snd xinfo))]
  in
  let (req_view : 'v) = join pre_view (vCoh addr s) in
  let wd = <| wd_w = w; wd_rexinfo = Maybe.map fst xinfo; 
              wd_req_view = to_view req_view |> in
  let state' = fun mwo -> 
    let post_view = to_v (ensure_mwo_successful mwo) in
    let ii = <| ii with instruction_kind = IK_mem_write wk |> in
    let ii = record_write ii w in
    let s = 
      s $> inc_vCoh addr post_view
        $> inc_vCAP addr_view
        $> inc_vWm post_view
        $> ifA (is_strong_release_W wk) (inc_vRel post_view)
        $> ifA (is_acquire_W wk) (inc_vRp post_view)
        $> ifA (is_acquire_W wk) (inc_vWp post_view)
        $> ifA (is_exclusive_W wk) (set_xcl_bank Nothing)
        $> set_fwd_bank addr (w.weiid,is_exclusive_W wk, addr_data_view)
        $> remove_promise w.weiid
    in
    let (s,ii,view,o) = do_local_effs (s,ii,post_view,c true) in
    make_tc (fst (finish_instruction params (s,ii,view,o)))
  in
  if exists ((p,_,_) IN (promises s)). p = w.weiid then
    let tl = make_label' (tid s) ii.instance_ioid wd state' in
    return (T_sync (T_Promising_fulfil_promise tl) ())
  else if in_shared_memory params (addr,sz) then
    let tl = make_label' (tid s) ii.instance_ioid (wd,false) state' in
    return (T_sync (T_Promising_propagate_write tl) ())
  else 
    let tl = make_label' (tid s) ii.instance_ioid wd state' in
    return (T_sync (T_Promising_propagate_write_nonshared tl) ())


val run_store_exclusive_instruction : forall 'v. View 'v, SetType 'v => instr_runner 'v
let run_store_exclusive_instruction params (s,ii,view,o) = 
  let (s,ii,view,o) = do_local_effs (s,ii,view,o) in
  let c = ensure_excl_res_outcome o in
  run_failed_store_exclusive_instruction params (s,ii,view,c false) 
  ::
  (option_guard (xcl_bank s) >>= fun rxinfo ->
   run_store_instruction (Just rxinfo) params (s,ii,view,c true))



let initialise_instruction params isem s (addr,opcode,instr) = 
  let o = isem.initial_outcome_s_of_instruction instr in
  let (ioid,ids) = gen_fresh_id (ids s) in
  let ii = starting_inst_instance_aux params isem ioid opcode instr addr
             (IK_simple,Set.empty,DIA_none,Set.empty,Set.empty,Set.empty)
             Set.empty o
  in
  let s = set_ids ids s in
  (s,ii,bot,o)

let run_instruction
    (params : model_params)
    (isem : instruction_semantics)
    (s : pts' 'v)
    ((addr,opcode,instr) : (address * maybe opcode * instruction_ast))
  : list (thread_trans pts) = 
  let (s,ii,view,o) = initialise_instruction params.t isem s (addr,opcode,instr) in
  if is_branch instr then 
    run_branch_instruction params (s,ii,view,o)
  else
    let (s,ii,view,o) = do_local_effs (s,ii,view,o) in
    match fst o with
    | Done _ -> run_plain_instruction params (s,ii,view,o)
    | Read_mem _ _ -> run_load_instruction params (s,ii,view,o)
    | Write_ea _ _ ->
       if is_amo instr
       then run_amo_instruction params (s,ii,view,o)
       else run_store_instruction Nothing params (s,ii,view,o)
    | Barrier _ _ -> run_barrier_instruction params (s,ii,view,o)
    | Excl_res _ -> run_store_exclusive_instruction params (s,ii,view,o)
    | _ -> fail
    end

let fail_fetch s (fde : fetch_and_decode_exception) = 
  let c () = make_tc s in
  let e = ET_fetch_and_decode fde in
  let l = (head (instrs s)).instance_ioid in
  T_only (make_label' (tid s) l (T_exception e) c)

let run_addr params isem (s : pts' 'v) addr = 
  match (prog s) addr with
  | FDO_address_not_concrete ->
     return (fail_fetch s (FDE_non_concrete_fetch_address_error))
  | FDO_illegal_fetch_address ->
     return (fail_fetch s (FDE_illegal_fetch_address_error addr))
  | FDO_decode_error de ->
     return (fail_fetch s (FDE_decode_error de addr))
  | FDO_success _ opcode instr -> 
     if params.t.thread_fail_on_loop &&
        exists (i MEM (instrs s)). i.program_loc = addr
     then failwith "found loop"
     else run_instruction params isem s (addr,opcode,instr)
  end
   
let cia_of_state params s = 
  let cia_rv = reg_value params.thread_isa_info.cia_reg s in
  let cia_al = ensure_just (address_lifted_of_register_value cia_rv) "fail" in
  let cia_a = addr_of_addr_lifted cia_al in
  cia_a

let cia_of_state' params = function
  | PTSTO s -> cia_of_state params s
  | PTSPO s -> cia_of_state params s
end

let quick_detect_deadlock = function
  | PTSTO ts ->
     exists ((wid,v,addr) IN promises ts). 
     not ((joinS [vWp ts;vCAP ts;vCoh addr ts]) < v)
  | PTSPO ts ->
     exists ((wid,WI v,addr) IN promises ts). 
     not (le (joinS [vWp ts;vCAP ts;vCoh addr ts]) (WI (Set.delete wid v)))
  end

let quick_quick_detect_deadlock = function
  | PTSTO ts ->
     exists ((wid,v,addr) IN promises ts). not (vCAP ts < v)
  | PTSPO ts ->
     exists ((wid,WI v,addr) IN promises ts). not (le (vCAP ts) (WI (Set.delete wid v)))
  end


let promising_enumerate_transitions_of_thread
    (params : model_params)
    (isem : instruction_semantics)
    (s : pts)
  : list (thread_trans pts) =
  let cia = cia_of_state' params.t s in
  guard (isJust (initAddr' s) && 
         cia <> (retAddr' s) &&
         not (quick_quick_detect_deadlock s)) >>
  match s with
  | PTSTO s -> run_addr params isem s cia
  | PTSPO s -> run_addr params isem s cia
  end


(* fix the params.thread_run_after_stop_promising case *)
let is_final_tstate params (s : pts) : bool =
  empty_promises' s && (cia_of_state' params s) = retAddr' s
    (* not params.thread_run_after_stop_promising *)



(*** System ********************************************************************)

let wd_of_prop_trans = function
  | T_trans (T_sync (T_Promising_propagate_write tl) _) -> return (fst tl.tl_label)
  | T_trans (T_sync (T_Promising_propagate_write_nonshared tl) _) -> return tl.tl_label
  | _ -> mzero
end

let wd_of_shared_prop_trans = function
  | T_trans (T_sync (T_Promising_propagate_write tl) _) -> Set.singleton (fst tl.tl_label)
  | _ -> Set.empty
end

let wd_of_trans = function
  | T_trans (T_sync (T_Promising_fulfil_promise tl) _) -> return tl.tl_label
  | T_trans (T_sync (T_Promising_propagate_write tl) _) -> return (fst tl.tl_label)
  | T_trans (T_sync (T_Promising_propagate_write_nonshared tl) _) -> return tl.tl_label
  | _ -> mzero
end

let unlockA_of_wd wd = option_guard wd.wd_rexinfo

let promising_shared_write : trans 'ts 'ss -> bool = function
  | T_trans (T_sync (T_Promising_propagate_write _) _) -> true
  | _ -> false
end

let promising_stop_promising : trans 'ts 'ss -> bool = function
  | SS_trans (SS_only SS_Promising_stop_promising _)  -> true
  | _ -> false
end

let promising_write : trans 'ts 'ss -> bool = function
  | T_trans (T_sync (T_Promising_propagate_write _) _) -> true
  | T_trans (T_sync (T_Promising_propagate_write_nonshared _) _) -> true
  | _ -> false
end


let ts_ss_after_trans old_memory : trans pts pss -> (pts * pss) = function

  | T_trans (T_only tl) -> 
     ((tl.tl_cont.tc_cont ()).tcr_state, old_memory)

  | T_trans (T_sync (T_Promising_mem_satisfy_read tl) Nothing) -> 
     let answer = ensure_just tl.tl_suppl "fail" in
     ((tl.tl_cont.tc_cont answer).tcr_state, old_memory)

  | T_trans (T_sync (T_Promising_mem_satisfy_read tl) (Just mc)) -> 
     let answer = ensure_just tl.tl_suppl "fail" in
     ((tl.tl_cont.tc_cont answer).tcr_state, mc ())

  | T_trans (T_sync (T_Promising_mem_satisfy_read_nonshared tl) Nothing) -> 
     let answer = ensure_just tl.tl_suppl "fail" in
     ((tl.tl_cont.tc_cont answer).tcr_state, old_memory)

  | T_trans (T_sync (T_Promising_propagate_write tl) (Just mc)) ->
     let answer = ensure_just tl.tl_suppl "fail" in
     ((tl.tl_cont.tc_cont answer).tcr_state, mc ())

  | T_trans (T_sync (T_Promising_propagate_write_nonshared tl) (Just mc)) ->
     let answer = ensure_just tl.tl_suppl "fail" in
     ((tl.tl_cont.tc_cont answer).tcr_state, mc ())

  | T_trans (T_sync (T_Promising_fulfil_promise tl) Nothing) ->
     let answer = ensure_just tl.tl_suppl "fail" in
     ((tl.tl_cont.tc_cont answer).tcr_state, old_memory)
  | _ -> fail
  end

let thread_trans_to_trans pts = function
  | T_only tl -> return (T_trans (T_only tl))
  | T_sync tsl _ -> promising_ss_receive_transitions pts tsl
  | T_thread_start _ -> failwith "cannot handle thread start"
  end

let promise_write (ss : pss) (ts : pts) (wd : writedata) : list (trans pts pss) = 
  let tc_cont = function
    | MWO_successful v ->
       let ts' = add_promise' (wd.wd_w.weiid,v,fst wd.wd_w.w_addr) ts in
       make_tc' ts'
    | _ -> fail
  end in
  let tl = make_label' wd.wd_w.w_thread wd.wd_w.w_ioid (wd,true) tc_cont in
  let thread_t = T_Promising_propagate_write tl in
  promising_ss_receive_transitions ss thread_t

let promises_fulfilled t = empty_promises' t


type certjob =
  <| CJpss : pss;
     CJpts : pts;
     CJpss_view : view;
     CJpromises : set writedata;
     CJfulfilled : bool;
     CJcert_no_write : bool;
     CJfuel : nat; |>

type cert = NotCertified
          | Certified of bool * set writedata

let le_View v1 v2 = 
  match (v1,v2) with
  | (Timestamp v1, Timestamp v2) -> le v1 v2
  | (Write_Ids v1, Write_Ids v2) -> le v1 v2
  | _ -> fail
  end

let promisable = le_View


let certprom_t params
    (isem : instruction_semantics)
    (cj : certjob)
    trans = 
  let (pts',pss') = ts_ss_after_trans cj.CJpss trans in
  let shared_wds = wd_of_shared_prop_trans trans in
  let newp = {wd | forall (wd IN shared_wds) 
                 | promisable wd.wd_req_view cj.CJpss_view} in
  let promises = newp union cj.CJpromises in
  let cert_no_write = cj.CJcert_no_write && Set.null shared_wds in
  <| cj with CJpts = pts';
             CJpss = pss';
             CJpromises = promises;
             CJfuel = cj.CJfuel - 1; 
             CJcert_no_write = cert_no_write |>

let rec certprom_s params
    (isem : instruction_semantics)
    (cjs : list (certjob)) 
    (cert : cert)
  : cert =
  match cjs with
  | [] -> cert
  | cj :: cjs ->
    let fulfilled = cj.CJfulfilled || promises_fulfilled cj.CJpts in
    let next_transitions = 
      if not (cj.CJfuel > 0)
      then let () = print_endline "\nWarning: ran out of fuel\n" in []
      else
        promising_enumerate_transitions_of_thread params isem cj.CJpts >>=
        thread_trans_to_trans cj.CJpss
    in 
    if not (List.null next_transitions) then
      let cj = <| cj with CJfulfilled = fulfilled |> in
      let new_cjs = List.map (certprom_t params isem cj) next_transitions in
      certprom_s params isem (new_cjs ++ cjs) cert
    else if not fulfilled then
      certprom_s params isem cjs cert
    else
      let cert = 
        match cert with
        | NotCertified -> Certified cj.CJcert_no_write cj.CJpromises
        | Certified cert_no_write promises ->
           Certified (cert_no_write || cj.CJcert_no_write) 
                     (promises union cj.CJpromises)
        end in
      certprom_s params isem cjs cert
  end

let certprom_transition params isem pts pss tr = 
  let (pts',pss') = ts_ss_after_trans pss tr in
  let cj = <| CJpts = pts';
              CJpss = pss';
              CJpromises = Set.empty;
              CJfulfilled = false;
              CJpss_view = pss_view pss;
              CJfuel = params.t.thread_promising_fuel;
              CJcert_no_write = Set.null (wd_of_shared_prop_trans tr);
           |> in
  certprom_s params isem [cj] NotCertified






let promising_enumerate_promising_transitions 
    (params : model_params)
    (isem : instruction_semantics)
    (stopped_promising : bool)
    (pts : pts)
    (pss : pss)
    : maybe (list (trans pts pss * bool)) =  (* 'Nothing' indicates a deadlock *)

  if stopped_promising && quick_detect_deadlock pts then Nothing else

  let trs = 
    promising_enumerate_transitions_of_thread params isem pts >>= 
    thread_trans_to_trans pss in

  let (transitions,promises) = 
    if stopped_promising
    then (List.map (fun tr -> (tr,true)) trs, Set.empty)
    else
      List.foldl (fun (trs,prms) tr ->
          match certprom_transition params isem pts pss tr with
          | NotCertified -> (trs,prms)
          | Certified cert_no_write promises ->
             ((tr,cert_no_write) :: trs, prms union promises)
          end
        ) ([],Set.empty) trs 
  in


  (* If the same promise can be done with different required views,
     only enumerate transitions for with biggest required view. In the
     timestamp case whether minimal/maximal or maximal is not
     important (just need a unique one), since this "locally required
     view" does not matter: we do not record that view but the view of
     memory "before" doing this write. In the write-ids model it does
     matter. Picking the promise(s) with maximal view constrains the
     storage subsystem the most. But that strongest constraint on the
     storage subsystem should still be weaker than the corresponding
     storage state in the timestamp model. *)
    let promises = 
        {p | forall (p IN promises)
           | not (exists (p' IN promises).
                  (p.wd_w = p'.wd_w &&
                   p.wd_rexinfo = p'.wd_rexinfo &&
                   (p'.wd_req_view <> p.wd_req_view &&
                    le_View p.wd_req_view p'.wd_req_view) ))
        } in

  let promises = Set_extra.toList promises in

  let promise_transitions = promises >>= fun wd ->
                            promise_write pss pts wd >>= fun tr ->
                            return (tr,false) in
  let transitions = transitions ++ promise_transitions in
  if List.null transitions && not (is_final_tstate params.t pts)
  then Nothing else Just transitions


val ptspo_normalise_view : psspo -> write_ids -> write_ids
let ptspo_normalise_view s (WI v) = 
  WI (bigunionMap (downclosure_f (fun w -> w.weiid) s) v)


let rec enumerate_possible_final_states
    (params : model_params)
    (isem : instruction_semantics)
    (pss : pss)
    (pts : pts)
  =
  if is_final_tstate params.t pts then return (pts,pss) else
    (* guard (quick_detect_deadlock pss pts) >> *)
    promising_enumerate_transitions_of_thread params isem pts >>= 
    thread_trans_to_trans pss >>= fun tr ->
    guard (not (promising_shared_write tr)) >>
    let (pts,pss) = ts_ss_after_trans pss tr in
    enumerate_possible_final_states params isem pss pts


let rec merge_pssto_memories m1 m2 =
  match (m1,m2) with
  | ([], []) -> []
  | (_ :: _, []) -> failwith "merge_memories: different length"
  | ([], _ :: _) -> failwith "merge_memories: different length"
  | ((w1,t1,maybetid1) :: ws1, (w2,t2,maybetid2) :: ws2) ->
     match (maybetid1,maybetid2) with
     | (Just tid1, Just tid2) ->
        failwith ("merge_pssto_memories: non-shared "^
                    "location accessed by different threads")
     | (Just _, _) ->
        (w1,t1,maybetid1) :: merge_pssto_memories ws1 ws2
     | (_, Just _) ->
        (w2,t2,maybetid2) :: merge_pssto_memories ws1 ws2
     | _ -> 
        (w1,t1,maybetid1) :: merge_pssto_memories ws1 ws2
     end
  end

let merge_pss_states s1 s2 =
  match (s1,s2) with
  | (PSSTO s1, PSSTO s2) ->
     let memory = merge_pssto_memories s1.pssto_memory s2.pssto_memory in
     PSSTO <| s1 with pssto_memory = memory |>
  | _ -> failwith "PSSTO expected"
  end


val make_ui_promising_thread_state_1 :
  forall 'v 'pts 'pss. View 'v, SetType 'v => pts' 'v -> ('v -> 'v) -> ui_thread_state 'pts 'pss
let make_ui_promising_thread_state_1 (t' : pts' 'v) view_transform = 
  UI_promising_thread_state 
  <| ui_promising_reg = List.map C3_unchanged (Map_extra.toList t'.reg);
     ui_promising_vReg = 
       List.map (fun (rbn,v) -> C3_unchanged (rbn,to_ui_view (view_transform v)))
         (Map_extra.toList t'.vReg) ;
     ui_promising_regdata = t'.regdata;
     ui_promising_vCoh = 
       List.map (fun (addr,v) -> C3_unchanged (addr,to_ui_view (view_transform v))) 
         (Map_extra.toList t'.vCoh) ;
     ui_promising_vRm = C2b_unchanged (to_ui_view (view_transform t'.vRm));
     ui_promising_vRp = C2b_unchanged (to_ui_view (view_transform t'.vRp));
     ui_promising_vWm = C2b_unchanged (to_ui_view (view_transform t'.vWm));
     ui_promising_vWp = C2b_unchanged (to_ui_view (view_transform t'.vWp));
     ui_promising_vCAP = C2b_unchanged (to_ui_view (view_transform t'.vCAP));
     ui_promising_vRel = C2b_unchanged (to_ui_view (view_transform t'.vRel));
     ui_promising_thread = t'.tid;
     ui_promising_instrs = [];
     ui_promising_fwd_bank =
       List.map (fun (addr,(wid,xcl,v)) -> C3_unchanged (addr,(wid,xcl,to_ui_view (view_transform v))))
         (Map_extra.toList t'.fwd_bank) ;
     ui_promising_xcl_bank =
       C2b_unchanged (Maybe.map (fun (x,v) -> (x,to_ui_view (view_transform v))) (t'.xcl_bank));
     ui_promising_promises = unchanged3_set (Set.map (fun (p,_,_) -> p) t'.promises);
     ui_promising_initAddr = C2b_unchanged t'.initAddr ;
     ui_promising_initRegS = t'.initRegS;
     ui_promising_last_ioid = Maybe.map (fun i -> i.instance_ioid) (index t'.instrs 0);
  |>


val make_ui_promising_thread_state_2 :
  forall 'v 'pts 'pss. View 'v, SetType 'v => pts' 'v -> pts' 'v -> list (ui_trans 'pts 'pss) ->
  ui_thread_state 'pts 'pss
let make_ui_promising_thread_state_2 t t' ncands = 
  UI_promising_thread_state 
  <| ui_promising_reg = ui_list_diff3 (Map_extra.toList t.reg) (Map_extra.toList t'.reg);
     ui_promising_vReg = 
       let vreg = List.map (fun (rbn,v) -> (rbn,to_ui_view v)) (Map_extra.toList t.vReg) in
       let vreg' = List.map (fun (rbn,v) -> (rbn,to_ui_view v)) (Map_extra.toList t.vReg) in
       ui_list_diff3 vreg vreg';
     ui_promising_regdata = t'.regdata;
     ui_promising_vCoh = 
       let coh = List.map (fun (a,v) -> (a,to_ui_view v)) (Map_extra.toList t.vCoh) in
       let coh' = List.map (fun (a,v) -> (a,to_ui_view v)) (Map_extra.toList t'.vCoh) in
       ui_list_diff3 coh coh';
     ui_promising_vRm = ui_eq_diff2b (to_ui_view t.vRm) (to_ui_view t'.vRm);
     ui_promising_vRp = ui_eq_diff2b (to_ui_view t.vRp) (to_ui_view t'.vRp);
     ui_promising_vWm = ui_eq_diff2b (to_ui_view t.vWm) (to_ui_view t'.vWm);
     ui_promising_vWp = ui_eq_diff2b (to_ui_view t.vWp) (to_ui_view t'.vWp);
     ui_promising_vCAP = ui_eq_diff2b (to_ui_view t.vCAP) (to_ui_view t'.vCAP);
     ui_promising_vRel = ui_eq_diff2b (to_ui_view t.vRel) (to_ui_view t'.vRel);
     ui_promising_thread = t'.tid;
     ui_promising_instrs = make_ui_instruction_list t.instrs t'.instrs ncands;
     ui_promising_xcl_bank =
       let xcl = Maybe.map (fun (x,v) -> (x,to_ui_view v)) t.xcl_bank in
       let xcl' = Maybe.map (fun (x,v) -> (x,to_ui_view v)) t'.xcl_bank in
       ui_eq_diff2b xcl xcl';
     ui_promising_fwd_bank = 
       let fwd = List.map (fun (a,(x,b,v)) -> (a,(x,b,to_ui_view v))) (Map_extra.toList t.fwd_bank) in
       let fwd' = List.map (fun (a,(x,b,v)) -> (a,(x,b,to_ui_view v))) (Map_extra.toList t'.fwd_bank) in
       ui_list_diff3 fwd fwd';
     ui_promising_promises = ui_set_diff3 (Set.map (fun (p,_,_) -> p) t.promises) (Set.map (fun (p,_,_) -> p) t'.promises);
     ui_promising_initAddr = ui_eq_diff2b t.initAddr t'.initAddr;
     ui_promising_initRegS = t'.initRegS;
     ui_promising_last_ioid = Maybe.map (fun i -> i.instance_ioid) (index t'.instrs 0);
  |>

let make_ui_promising_thread_state 
      (s : pss)
      (t : maybe pts) 
      (t' : pts) 
      (ncands: list (ui_trans 'ts 'ss)) 
    : (ui_thread_state 'ts 'ss) =
  match (s,t,t') with
  | (_, Nothing, PTSTO t') ->
     make_ui_promising_thread_state_1 t' id 
  | (PSSPO s, Nothing, PTSPO t') ->
     make_ui_promising_thread_state_1 t' (ptspo_normalise_view s)
  | (_, Just (PTSTO t), PTSTO t') ->
     make_ui_promising_thread_state_2 t t' ncands
  | (_, Just (PTSPO t), PTSPO t') ->
     make_ui_promising_thread_state_2 t t' ncands
  | _ -> fail
  end


let promising_thread : (threadSubsystem pts) = 
  <| ts_tid = tid';
     ts_initial_fetch_address = initAddr';
     ts_initial_reg_state = initRegS';
     ts_final_reg_state = promising_registers_final_state;
     ts_instruction_tree = fun ts -> (List.reverse (instrs' ts),T []);
     ts_update_initial_register_state = promising_update_initial_register_state;
     ts_update_initial_fetch_address = promising_update_initial_fetch_address;
     ts_is_final_state = is_final_tstate;
     (* ts_make_ui_thread_state = make_ui_promising_thread_cert_state; *)
     ts_initial_thread_state = promising_initial_thread_state;
 |>



val merge_combination : list (thread_id * (pts * pss)) -> map thread_id pts * pss
let merge_combination combination =
  match combination with
    | [] -> failwith "merge_combinations"
    | (tid,(pts,pss)) :: rest ->
       let add (ptss,pss) (tid',(pts',pss')) =
         (Map.insert tid' pts' ptss, merge_pss_states pss pss')
       in
       List.foldl add (Map.singleton tid pts, pss) rest
  end



val all_combinations : forall 'a 'b. list ('a * list 'b) -> list (list ('a * 'b))
let rec all_combinations l = 
  match l with
  | [] -> [[]]
  | (a, bs) :: rest ->
     [(a,b) :: combinations 
        | forall (b MEM bs) (combinations MEM all_combinations rest) | true]
  end

let enumerate_finalise_transitions isem state = 
  if promising_ss_is_final_state state.model.ss state.storage_subsystem &&
       Map.all (fun _ ts -> is_final_tstate state.model.t ts) state.thread_states
  then []
  else
    let pss = state.storage_subsystem in
    let ptss = Map_extra.toList state.thread_states in
    let (final_states_per_thread : list (thread_id * (list (pts * pss)))) =
      List.map (fun (tid,pts) -> (tid, enumerate_possible_final_states state.model isem pss pts)) ptss in
    let (combinations : list (list (thread_id * (pts * pss)))) = all_combinations final_states_per_thread in
    List.map merge_combination combinations


let promising_enumerate_transitions_of_system
    (is_option:           instruction_semantics_option)
    (* current system state *)
    (state:               system_state pts pss)
    (* cached transitions *)
    (_: maybe (list (ss_trans pss)))
    (_: map thread_id (list (thread_trans pts)))
    (cached_sys_thread_trans: map thread_id (list (trans pts pss * bool)))
    : (list (trans pts pss)) * 
        (list (ss_trans pss)) * 
          (map thread_id (list (thread_trans pts))) *
            (map thread_id (list (trans pts pss * bool)))  
  =
  let isem = state.instruction_semantics is_option in

  let stopped_promising = stopped_promising state.storage_subsystem in

  let stop_running =
    stopped_promising && not (state.model.t.thread_run_after_stop_promising) in

  if stop_running then
    let (possible_states : list (map thread_id pts * pss)) =
      enumerate_finalise_transitions isem state in
    let transitions = List.map (fun (ptss, pss) -> Sys_trans ptss pss) possible_states in
    let transitions' = Map.singleton 1000 (List.map (fun tr -> (tr,true)) transitions) in
    (transitions, [], Map.empty, transitions')
  else
  
  let stop_certifying =
    stopped_promising && not (state.model.t.thread_certify_after_stop_promising) in




  let sys_thread_transitions : map thread_id (list (trans pts pss * bool)) =

    let (transitions,_already_have_one,deadlock) : (map thread_id (list (trans pts pss * bool)) * bool * bool) = 
      Map_extra.fold
        (fun tid ts (m,already_have_one,deadlock) ->
         match Map.lookup tid cached_sys_thread_trans with
         | Just [] -> (Map.insert tid [] m, already_have_one, deadlock)
         | Just trs -> (Map.insert tid trs m, true, deadlock)
         | Nothing ->
            if already_have_one && stopped_promising
            then (m,already_have_one,deadlock)
            else
              match promising_enumerate_promising_transitions
                      state.model isem stop_certifying ts state.storage_subsystem with
              | Just [] -> (Map.insert tid [] m, false, deadlock)
              | Just trs -> (Map.insert tid trs m, true, deadlock)
              | Nothing -> (m, true, true)
              end
         end
        )
        state.thread_states (Map.empty,false,false)
    in

    if deadlock then Map.empty else transitions
  in


  let can_stop_promising = 
    not stopped_promising &&
    Map.all (fun tid trs ->
        let ts = Map_extra.find tid state.thread_states in
        state.t_model.ts_is_final_state state.model.t ts|| List.any snd trs)
      sys_thread_transitions
  in

  let storage_transitions = 
    guard can_stop_promising >>
    promising_ss_enumerate_transitions state.model state.storage_subsystem 
  in

  let filter (tr,cert_no_write) = 
    ((state.model.t.thread_certify_after_stop_promising && stopped_promising) --> 
       cert_no_write) &&
    ((state.model.t.thread_certify_after_stop_promising && stopped_promising) --> 
       not (promising_shared_write tr)) &&
    ((state.model.ss.promise_first && not stopped_promising) --> 
      promising_shared_write tr)
  in
  let thread_transitions = 
    Map_extra.fold (fun _ trs acc -> acc ++ (List.filter filter trs))
      sys_thread_transitions []
  in

  ((List.map fst thread_transitions) ++ storage_transitions, [],
   Map.empty, sys_thread_transitions)



let promising_system : system pts pss = 
  <| s_make_ui_system_state = make_ui_system_state 
                                make_ui_promising_thread_state
                                make_ui_promising_storage_state;
     s_enumerate_transitions_of_system = promising_enumerate_transitions_of_system;
  |>




