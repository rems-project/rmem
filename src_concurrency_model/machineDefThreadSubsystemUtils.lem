(*===============================================================================*)
(*                                                                               *)
(*                rmem executable model                                          *)
(*                =====================                                          *)
(*                                                                               *)
(*  This file is:                                                                *)
(*                                                                               *)
(*  Copyright Christopher Pulte, University of Cambridge    2017-2018            *)
(*  Copyright Shaked Flur, University of Cambridge          2017-2018            *)
(*  Copyright Robert Norton-Wright, University of Cambridge      2017            *)
(*  Copyright Jon French, University of Cambridge                2018            *)
(*                                                                               *)
(*  All rights reserved.                                                         *)
(*                                                                               *)
(*  It is part of the rmem tool, distributed under the 2-clause BSD licence in   *)
(*  LICENCE.txt.                                                                 *)
(*                                                                               *)
(*===============================================================================*)

(* emacs fontification -*-caml-*- *)

open import Pervasives_extra

open import Sail_impl_base
open import Utils
open import Fragments
open import FreshIds
open import ExceptionTypes
open import Events
open import Debug
open import InstructionSemantics
open import Params
open import Isa
open import RegUtils
open import UiTypes
open import InstructionKindPredicates

open import MachineDefTypes
open import MachineDefUI

(** Error reporting *************************************************)

val catch_thread_errors : forall 'a. thread_id -> ioid -> (unit -> 'a) -> 'a
declare ocaml target_rep function catch_thread_errors = `Debug.catch_thread_errors`


(** subreads and subwrites *)



let write_initiated inst = inst.subwrites.sw_addr <> Nothing
let write_instantiated inst = 
  write_initiated inst && 
  List.null inst.subwrites.sw_potential_write_addresses
let write_committed inst = inst.subwrites.sw_committed

let all_read_writes_have_their_values inst = 
  forall ((_, wss) MEM inst.subreads.sr_writes_read_from) ((w,_) MEM wss).
  w.w_value <> Nothing

let propagated_writes_of_inst inst = 
  inst.subwrites.sw_propagated_writes

let unpropagated_writes_of_inst inst = 
  inst.subwrites.sw_potential_write_addresses
  ++ inst.subwrites.sw_potential_writes

let all_writes_of_inst inst = 
  propagated_writes_of_inst inst ++ 
    unpropagated_writes_of_inst inst


let mark_write_as_committed i = 
  let subwrites' = <| i.subwrites with sw_committed = true |> in
  <| i with subwrites = subwrites' |>

let set_successful_atomic_store i = 
  <| i with successful_atomic_store = Just true |>

let set_unsuccessful_atomic_store i = 
  <| i with successful_atomic_store = Just false |>

let mark_write_as_propagated i write = 
  let subwrites' = 
    <| i.subwrites with
         sw_potential_writes = List.delete write i.subwrites.sw_potential_writes;
         sw_propagated_writes = write :: i.subwrites.sw_propagated_writes;
    |>
  in
  <| i with subwrites = subwrites' |>





let read_initiated inst = inst.subreads.sr_addr <> Nothing
let read_completed inst = inst.subreads.sr_assembled_value <> Nothing
let read_requested inst rr = List.lookup rr inst.subreads.sr_requested <> Nothing

(* the following means the domains of the lists are identical *)
let all_read_requests_issued inst = 
  read_initiated inst &&
    (List.length inst.subreads.sr_requested = 
     List.length inst.subreads.sr_unsat_slices)

let all_reads_satisfied inst = 
  read_initiated inst &&
  forall ((_, slices) MEM inst.subreads.sr_unsat_slices).
  slices = []

let unsat_slices_of_read_request inst rr = 
  ensure_just (List.lookup rr inst.subreads.sr_unsat_slices)
  $ "missing a read-request in 'sr_unsat_slices' of ioid " ^
      show inst.instance_ioid

let sat_slices_of_read_request inst rr = 
  ensure_just (List.lookup rr inst.subreads.sr_writes_read_from)
  $ "missing a read-request in 'sr_writes_read_from' of ioid " ^
      show inst.instance_ioid


let initial_subreads = 
  <|  sr_addr =             Nothing;
      sr_unsat_slices =     [];
      sr_writes_read_from = [];
      sr_requested =        [];
      sr_assembled_value =  Nothing;
  |>




let mark_read_as_requested i rr unsat_slices = 
  let sr_requested' = (rr, unsat_slices) :: i.subreads.sr_requested in
  let subreads = <| i.subreads with sr_requested = sr_requested' |> in
  <| i with subreads = subreads |>

let mark_read_as_satisfied i rr unsat_slices writes_read_from = 
  let sr_unsat_slices' = updateAssocList rr unsat_slices i.subreads.sr_unsat_slices in
  let sr_writes_read_from' =
    updateAssocList rr writes_read_from i.subreads.sr_writes_read_from in
  let subreads' = <| i.subreads with sr_unsat_slices = sr_unsat_slices';
                                     sr_writes_read_from = sr_writes_read_from' |>
  in
  <| i with subreads = subreads' |>

let mark_read_as_completed i value = 
  let subreads' = <| i.subreads with sr_assembled_value = Just value; |> in
  let i' = <| i with subreads = subreads' |> in
  i'


(* return all the read-requests of subreads' *)
let read_requests_of_subreads subreads : list read_request =
  fst (List.unzip subreads.sr_unsat_slices)


(** Sail_impl_base.reg_name Utils *********************************)

val reg_info : forall 'i. isa 'i -> string -> maybe string -> (nat * nat * direction * (nat * nat))
let reg_info isa regname regfield =
  let reg = match regfield with
    | Just regfield -> reg_field_from_data isa.register_data_info regname regfield
    | Nothing -> reg_from_data isa.register_data_info regname
  end in
  let reg = Maybe_extra.fromJust reg in
  let sl =
    let (i, j) = slice_of_reg_name reg in
    match direction_of_reg_name reg with
    | D_increasing -> (i, j)
    | D_decreasing ->
        let start = start_of_reg_name reg in
        (start - i, start - j)
    end
  in
  (start_of_reg_name reg, width_of_reg_name reg, direction_of_reg_name reg, sl)

(* return all the slices of r's base-register that i is known to
write to based on the static footprint analysis (regs_out) *)
let reg_out_slices (r: reg_name) (i: instruction_instance 'i)
    : list (reg_name * maybe_value_fragment bit_lifted)
  =
  let r_name = register_base_name r in
  List.mapMaybe
    (fun r' ->
      if register_base_name r' = r_name then Just (r', (slice_of_reg_name r', Nothing))
      else Nothing)
    (Set_extra.toList i.regs_out)


(* return all the slices of r's base-register that i has written to *)
let reg_write_slices (r: reg_name) (i: instruction_instance 'i)
    : list (reg_name * maybe_value_fragment bit_lifted)
  =
  let r_name = register_base_name r in
  List.mapMaybe
    (fun (r', (_, rv)) ->
      if register_base_name r' = r_name then
        let slice = slice_of_reg_name r' in
        let () =
          ensure (slice = (rv.rv_start, rv.rv_start + (List.length rv.rv_bits) - 1))
            $ "reg_write_slices saw a value with non-matching start index or length " ^ register_base_name r
        in
        Just (r', (slice, Just rv.rv_bits))
      else Nothing)
    i.reg_writes


(** Inter-instruction Register Reading ******************************)

(* SF: this should be next to the type definition *)
let ioids_of_rrs (rrs: register_read_sources) : set ioid =
  List.mapMaybe
    (function
    | RRS_instruction ioid _ _ -> Just ioid
    | RRS_initial_state _      -> Nothing
    | RRS_pseudoregister       -> Nothing
    end)
    rrs
  $> Set.fromList

type find_reg_read_outcome =
  (* found a write of the particular register by that instruction with that
     value *)
  | FRRO_found of register_read_sources * register_value

  (* register read is blocked as some required instruction with that register
     in its footprint hasn't done a register write to it yet, or an initial
     value is required but the initial values were not provided. *)

  | FRRO_blocked of register_read_sources

  (* DEADCODE: FRRO_not_found is never used to construct a value *)
  (* no instruction in the prefix has the register in its footprint *)
  | FRRO_not_found


(* overview: to do a register read, walk back through the instructions, and
   through the register writes in the footprint of each.  Maintain the "footprint
   needed" as a list of disjoint slices (in increasing order).  Check for each
   write in the current footprint whether that overlaps the footprint needed
   (not, partially, or completely).  If there's a non-empty intersection and the
   write hasn't been done yet, signal blockedness; otherwise, stash away the
   value for the intersection.  If one gets to the end, do the same with a
   pseudo-write from the initial register state.  Then glue together the value
   fragments into a list, by sorting and checking adjacency. *)


(* TODO: what about cases where the footprint includes multiple register writes
   to overlapping parts of a register?  TODO: surely the slice type should use
   int not integer (they will never be more than 2^31... or indeed nat) *)

(* TODO: note that this assumes that if a register is in i.regs_out then i
   *will* eventually write to it.  Is that true? If not, can we make it so by
   reasonable patching, or do we have to dynamically recalculate i's register write
   footprint? (SF: this was relaxed a bit, see comment in machineDefTypes.lem
   next to regs_out).
   It further assumes that an instruction writes exactly once to each of its regs_out,
   otherwise this might pick up a "register coherence hidden" value by reading too
   early. *)

(* find *)
let rec find_reg_read'
    (init_values: maybe (registerdata * (reg_base_name -> register_value)))
    (r:           reg_name)
    (needed :     list (nat*nat))
    (* acc_found will be used to calculate the read value *)
    (acc_found:   list (maybe_value_fragment bit_lifted))
    (* acc_source will be the register_read_sources at the end*)
    (acc_source:  list register_read_source)
    (is:          list (instruction_instance 'i))
    : find_reg_read_outcome
  =
  let reassemble acc_found acc_source =
    match reassemble_register_value r acc_found with
    | Nothing -> FRRO_blocked (List.reverse acc_source)
    | Just v  -> FRRO_found (List.reverse acc_source) v
    end
  in

  if needed = [] then reassemble acc_found acc_source else

  match is with
  | [] ->
      match init_values with
      | Nothing ->
          (* we need to read from the initial state but we were not given
          one, so we will return FRRO_blocked *)
          FRRO_blocked (List.reverse acc_source)
      | Just (registerdata, init_values') ->
          (* get the base-register *)
          let base_reg : reg_name = ensure_just (reg_from_data registerdata (register_base_name r))
              ("the register \"" ^ show (register_base_name r) ^ "\" is not defined in MachineDef*")
          in
          (* get the initial value for the base-register register *)
          let init_val = init_values' (register_base_name r) in
          let init_mvf = (slice_of_reg_name base_reg, Just init_val.rv_bits) in
          match match_maybe_value_fragment needed init_mvf with
          | ([], found) -> reassemble (found ++ acc_found) (RRS_initial_state found :: acc_source)
          | _           -> fail
          end
      end

  | i :: is' ->
      match reg_out_slices r i with
      | [] -> find_reg_read' init_values r needed acc_found acc_source is'
      | reg_out_slices ->
          let got =
            let reg_write_slices = reg_write_slices r i in
            (* if the instruction has finished its execution we can ignore
            the static analysis and use the actual register writes. This might
            be important if the static analysis is an over-approximation *)
            if i.finished then reg_write_slices
            else reg_write_slices ++ reg_out_slices
          in

          let (needed, found, reg_names) =
            List.foldl
              (fun (needed, acc_fragments, acc_reg_names) (reg_name, mvf) ->
                match needed with
                | [] -> ([], acc_fragments, acc_reg_names)
                | _  ->
                    match match_maybe_value_fragment needed mvf with
                    | (_,      [])    -> (needed, acc_fragments, acc_reg_names)
                    | (needed, found) -> (needed, found ++ acc_fragments, reg_name :: acc_reg_names)
                    end
                end)
              (needed, [], [])
              got
          in

          let acc_found' = found ++ acc_found in
          let acc_source' =
            match found with
            | [] -> acc_source
            | _  -> (RRS_instruction i.instance_ioid reg_names found) :: acc_source
            end
          in
          find_reg_read' init_values r needed acc_found' acc_source' is'
      end
  end


(* if init_values is Nothing and an initial value is needed, the
result will be FRRO_blocked with the register_read_sources collected
from instructions *)
let find_reg_read
    (init_values: maybe (registerdata * (reg_base_name -> register_value)))
    (r:           reg_name)
    (is:          list (instruction_instance 'i))
    : find_reg_read_outcome
  =
  let needed = [slice_of_reg_name r] in
  find_reg_read' init_values r needed [] [] is


let find_register_snapshot
    (register_data:          registerdata)
    (initial_register_state: reg_base_name -> register_value)
    (is:                     list (instruction_instance 'i))
    : list (reg_base_name * maybe register_value)  (* = register_snapshot *)
  =
  List.map
    (fun (rbn, (dir, width, start_index, _)) ->
        (* TODO: Need to check that this is the correct start_index for D_decreasing *)
        let r = Reg rbn start_index width dir in
        let mv =
          match find_reg_read (Just (register_data, initial_register_state)) r is with
          | FRRO_found rrs v -> Just v
          | FRRO_blocked _   -> Nothing
          | FRRO_not_found   -> failwith "find_register_snapshot FRRO_not_found"
          end in
        (rbn, mv))
    register_data


let ioids_feeding_regs
    (po:   list (instruction_instance 'i)) (* head is new *)
    (regs: set reg_name)
    : set ioid
  =
  bigunionMap
    (fun reg ->
      match find_reg_read Nothing reg po with
      | FRRO_found rrs _ -> ioids_of_rrs rrs
      | FRRO_blocked rrs -> ioids_of_rrs rrs
      | FRRO_not_found   -> {}
      end)
    regs


(* also see registers_final_state below *)


let rec undetermined_reg_writes_read_from_helper active_prefix ioid reg_names : set ioid =
  match active_prefix with
  | [] -> {}  (* if ioid is not in active_prefix then it is an old
              instruction (i.e. finished) *)
  | i :: active_prefix ->
      if i.instance_ioid = ioid then
        if i.finished then {} else
        (* NOTE: we assume rmw instructions write to registers only in the load part *)
        if i.rmw_finished_load_snapshot <> Nothing then {} else

        Set.fromList reg_names
        $> Set.bigunionMap (fun reg ->
            match List.lookup reg i.reg_writes with
            | Just (dependencies, _) ->
                Set.fromList dependencies
                $> Set.bigunionMap (function
                    | RWD_reg_write ioid reg_names -> undetermined_reg_writes_read_from_helper active_prefix ioid reg_names
                    | RWD_mem_read -> {ioid}
                    end)
            | Nothing -> {ioid}
                (* the register write disappeared, i.e. i was restarted,
                yet the register dependent instruction that initiated this
                check was not restarted. That can happen when the register
                write is deterministic (e.g. the status register of AArch64
                STXR). This means we can return {} here, but it feels unsafe.
                Since this scenario involves restarts it does not really
                matter, so I do the safer thing which is to return {ioid}. *)
            end)

      else undetermined_reg_writes_read_from_helper active_prefix ioid reg_names
  end

let undetermined_reg_writes_read_from
    (active_prefix: list (instruction_instance 'i))
    (reg_reads:     list (reg_name * register_read_sources * register_value))
    : set ioid
  =
  Set.fromList reg_reads
  $> Set.bigunionMap (fun (_, register_read_sources, _) ->
      Set.fromList register_read_sources
      $> Set.bigunionMap (function
          | RRS_instruction ioid reg_names _ -> undetermined_reg_writes_read_from_helper active_prefix ioid reg_names
          | RRS_initial_state _ -> {}
          | RRS_pseudoregister  -> {}
          end))



(** Instruction Tree Manipulation ***********************************)

let rec forall_iprev_with_prefix
    (prefix: list (instruction_instance 'i))
    (p:      instruction_instance 'i -> list (instruction_instance 'i) -> bool)
    : bool
  =
  match prefix with
  | [] -> true
  | iprev :: prefix ->
      if p iprev prefix then forall_iprev_with_prefix prefix p
      else false
  end

let rec exists_iprev_with_prefix
    (prefix: list (instruction_instance 'i))
    (p:      instruction_instance 'i -> list (instruction_instance 'i) -> bool)
    : bool
  =
  match prefix with
  | [] -> false
  | iprev :: prefix ->
      if p iprev prefix then true
      else exists_iprev_with_prefix prefix p
  end

(* break 'it' to a set of tuples of the form (prefix', inst', it') where inst'
   is an instruction, prefix' is the list of po-previous instructions concatenated
   with prefix (head is closer to inst', i.e.  reverse po) and it' is the po-after
   tree. *)
let rec set_of_instruction_tree
    (prefix: list (instruction_instance 'i))
    (T iis:  instruction_tree 'i)
    : set (list (instruction_instance 'i) *
           instruction_instance 'i *
           instruction_tree 'i)
  =
  match iis with
  | [] -> {}
  | (i,it) :: iis ->
     (Set.insert (prefix,i,it) (set_of_instruction_tree (i::prefix) it)) union
     (set_of_instruction_tree prefix (T iis))
  end


(* return all the instructions in 'it' as a set *)
let instructions_of_tree (it: instruction_tree 'i) : set (instruction_instance 'i) =
  Set.map (fun (_,i,_) -> i) (set_of_instruction_tree [] it)

let ioids_of_instruction_tree (it: instruction_tree 'i) : set ioid =
  Set.map (fun i -> i.instance_ioid) (instructions_of_tree it)

(* for each instruction in 'it' apply 'f prefix' inst' it'' where
inst' is the instruction, prefix' is the list of po-previous
instructions concatenated with 'prefix' (head is closer to inst', i.e.
reversed po, similar to active_prefix) and it' is the po-after tree. *)
let rec instruction_tree_map
    (f:         (list (instruction_instance 'i)) -> 
                 instruction_instance 'i -> 
                 instruction_tree 'i -> 
                 instruction_instance 'i)
    (prefix:    list (instruction_instance 'i))
    (T iiits:   instruction_tree 'i)
    : instruction_tree 'i
  =
  T (List.map (fun (ii, it') -> (f prefix ii it', instruction_tree_map f (ii :: prefix) it'))
              iiits)


(* Return Just (prefix', inst', it') of the first (in pre-order) instruction in
   'it' for which 'f prefix' inst' it'' is true where inst' is the instruction,
   prefix' is the list of po-previous instructions concatenated with 'prefix' (head
   is closer to inst', i.e.  reversed po, similar to active_prefix) and it' is the
   po-after tree.  Return Nothing if no such instruction is found *)
let rec instruction_tree_find
    (f:       (list (instruction_instance 'i) -> 
               instruction_instance 'i -> 
               instruction_tree 'i -> bool))
    (prefix:  list (instruction_instance 'i))
    (it:      instruction_tree 'i)
    : maybe (list (instruction_instance 'i) * instruction_instance 'i * instruction_tree 'i)
  =
  let is = Set_extra.toList (set_of_instruction_tree prefix it) in
  List.find (fun (prfx,i,it) -> f prfx i it) is


let instruction_tree_any
    (f:         (list (instruction_instance 'i)) -> instruction_instance 'i -> instruction_tree 'i -> bool)
    (prefix:    list (instruction_instance 'i))
    (it:        instruction_tree 'i)
    : bool
  =
  instruction_tree_find f prefix it <> Nothing

let instruction_tree_all
    (f:         (list (instruction_instance 'i)) -> instruction_instance 'i -> instruction_tree 'i -> bool)
    (prefix:    list (instruction_instance 'i))
    (it:        instruction_tree 'i)
    : bool
  =
  not (instruction_tree_any (fun is i it -> not (f is i it)) prefix it)

(* apply fold to every path from root to leaves and return the set of results *)
let rec instruction_tree_fold_root
    (f:      'a -> list (instruction_instance 'i) -> instruction_instance 'i -> instruction_tree 'i -> 'a)
    (prev:   'a)
    (prefix: list (instruction_instance 'i))
    (T iis:  instruction_tree 'i)
    : set 'a
  =
  match iis with
  | [] -> {prev}
  | (i,it) :: iis ->
     (instruction_tree_fold_root f (f prev prefix i it) (i::prefix) it) union
     instruction_tree_fold_root f prev prefix (T iis)
  end

let instructions_with_prefix_ioids (it : instruction_tree 'i)
    : set (instruction_instance 'i * set ioid)
  = 
  let fold (acc,prefix_ioids) _ i _ = 
    (Set.insert (i,prefix_ioids) acc,
     Set.insert i.instance_ioid prefix_ioids)
  in
  Set.bigunion (Set.map fst (instruction_tree_fold_root fold ({}, {}) [] it))



(* find all the in-flight instruction instances in a thread's instruction_tree,
   together with the tree context for each *)
let rec filter_instructions
    (p:          instruction_instance 'i -> bool)
    (T iis:      instruction_tree 'i)
    (itcns:      list (instruction_tree_context_node 'i))  (* accumulating context *)
    (prefix:     instruction_prefix 'i)  (* accumulating prefix *)
    (prefix_old: instruction_prefix 'i)  (* fixed old prefix *)
    : list (instruction_in_context 'i) =
  List.concat
    (mapWithContext
       (fun left ((i,it') : instruction_instance 'i * instruction_tree 'i) right ->
         let in_flights_of_subtree =
           filter_instructions p it' (ITC_node left i right :: itcns) (i::prefix) prefix_old in
         if p i then
           <| iic_instance = i;
              context       = ITC_innermost left right itcns;
              subtree       = it';
              active_prefix = prefix;
              old_prefix    =  prefix_old
           |>
             :: in_flights_of_subtree
         else
           in_flights_of_subtree)
       iis)


let in_flight_instructions state : list (instruction_in_context 'i) =
  filter_instructions (fun i -> not i.finished) (state.instruction_tree) [] [] 
                      (state.old_instructions)


let un_old_instructions state : list (instruction_in_context 'i) =
  filter_instructions (fun _ -> true)
                      (state.instruction_tree) [] [] (state.old_instructions)

let un_old_finished_instructions state : list (instruction_in_context 'i) =
  filter_instructions (fun i -> i.finished)
                      (state.instruction_tree) [] [] (state.old_instructions)

let find_ioid_instruction_in_context state ioid : maybe (instruction_in_context 'i) =
  match filter_instructions (fun i -> i.instance_ioid = ioid)
                            (state.instruction_tree) [] []
                            (state.old_instructions) with
  | head :: [] -> Just head
  | [] -> Nothing
  | _ -> failwith $ "ioid " ^ show ioid ^ " appears more than once in the instruction tree"
  end


(* wrap an instruction_tree_context around an instruction instance and subtree *)
let rec apply_tree_context_nodes
    (ictns: list (instruction_tree_context_node 'i))
    (it:    instruction_tree 'i)
    : instruction_tree 'i =
  match ictns with
  | [] -> it
  | (ITC_node left i right) :: ictns' ->
      let it' = T (left ++ ((i,it) :: right)) in
      apply_tree_context_nodes ictns' it'
  end

let rec apply_tree_context
    (ITC_innermost left right ictns: instruction_tree_context 'i)
    ((i, it):                        instruction_instance 'i * instruction_tree 'i)
    : instruction_tree 'i =
  let it' = T (left ++ ((i,it) :: right)) in
  apply_tree_context_nodes ictns it'

(* return a new iic for one instruction up (i.e. the head of active_prefix)
if such instruction exists, otherwise Nothing *)
let prev_instruction_in_context (iic: instruction_in_context 'i) : maybe (instruction_in_context 'i) =
  match iic.context with
  | (ITC_innermost _ _ []) -> Nothing
  | (ITC_innermost left right ((ITC_node left' i' right') :: ictns')) ->
      let it' = T (left ++ ((iic.iic_instance, iic.subtree) :: right)) in
      let active_prefix' =
        match iic.active_prefix with
        | [] -> failwith "expected non-empty active_prefix"
        | _ :: tail -> tail
        end
      in
      Just <| iic_instance = i';
              context       = ITC_innermost left' right' ictns';
              subtree       = it';
              active_prefix = active_prefix';
              old_prefix    = iic.old_prefix;
           |>
  end

(* return a new iic for the first instruction in 'iic.iic_instance :: iic.active_prefix'
for which 'f' is true *)
let rec find_prev_iic
    (f: instruction_instance 'i -> bool)
    (iic: instruction_in_context 'i)
    : maybe (instruction_in_context 'i)
  =
  if f iic.iic_instance then Just iic
  else
    Maybe.bind (prev_instruction_in_context iic) $ fun iic' -> find_prev_iic f iic'

let find_prev_ioid_iic
    (ioid: ioid)
    (iic:  (instruction_in_context 'i))
    : maybe (instruction_in_context 'i)
  =
  find_prev_iic (fun i -> i.instance_ioid = ioid) iic


(* collapse old instructions back into the instruction tree (for UI) *)
let rec tree_of_old_and_new_instructions_helper
    (it: instruction_tree 'i)
    (is: list (instruction_instance 'i))
    : instruction_tree 'i
  =
  match is with
  | []      -> it
  | i :: is -> tree_of_old_and_new_instructions_helper (T [(i, it)]) is
  end

let tree_of_old_and_new_instructions (s: thread_state 'i) : instruction_tree 'i =
  tree_of_old_and_new_instructions_helper s.instruction_tree s.old_instructions

let _count_pairs (prefix:list (instruction_instance 'i)) (us:address) (them:address) (acc:nat) =
  _count_pairs_aux prefix (fun ii -> ii.program_loc) us them acc


(** The Default Successor Instruction Address ***********************)
(* used for fetching and in branch commit *)

let successor_fetch_address (i: instruction_instance 'i) : address =
  add_address_nat i.program_loc 4  (* TODO not if at end of address space - cf 2.06B *)

let next_address_of_finished_instruction isa (i: instruction_instance 'i) : address =
  let () = ensure (isa.isa_model <> MIPS)
      "next_address_of_finished_instruction not implemented for MIPS"
  in
  match List.lookup isa.nia_reg i.reg_writes with
  | Just (_, rv) ->
    let al = ensure_just (address_lifted_of_register_value rv)
                        "NIA/PC register write not 64 bits" in
    ensure_just (address_of_address_lifted al) "NIA/PC not a concrete address"
  | Nothing -> successor_fetch_address i
  end


let mips_delayed_pc_of_finished_instruction isa (i: instruction_instance 'i) : maybe address =
  let dia_reg = ensure_just isa.dia_reg "expected a dia reg for mips" in
  match List.lookup dia_reg i.reg_writes with (* TODO branch likely *)
  | Just (_, rv) ->
     let al = ensure_just (address_lifted_of_register_value rv)
                          "delayedPC register write not 64 bits" in
     let a = ensure_just (address_of_address_lifted al) "delayedPC not a concrete address" in
     Just a
  | Nothing -> Nothing
  end

let mips_next_next_pc_of_finished_instruction isa (i: instruction_instance 'i) : address =
  (* look for a write to delayedPC otherwise branch untaken *)
  match mips_delayed_pc_of_finished_instruction isa i with
  | Just a  -> a
  | Nothing -> add_address_nat (successor_fetch_address i) 4
  end


(** Initial instruction state, and recalculations, and restarts *)

let analyse_instruction
    isa
    (reanalyse: bool)
    (environment : (list (reg_name * register_value)))
    (old_outcome : outcome unit)
    (inst:        'i)
    (iprefix:     list (instruction_instance 'i))
    (cia_address: address)
    : instruction_kind * set nia * dia * set reg_name * set reg_name * set reg_name
  =

  let cia_reg = isa.cia_reg in
  let environment =
    ((cia_reg,pseudo_register_value isa cia_address cia_reg) ::
      isa.fixed_pseudo_registers) ++ environment in

  let (regs_in,regs_out,regs_feeding_address,nias,dia,ik) =
    isa.instruction_semantics.instruction_analysis
      inst reanalyse (reg_info isa) environment
  in

  let (regs_in,regs_out,regs_feeding_address,nias) =
    (non_pseudo_registers isa (fromList regs_in),
     non_pseudo_registers isa (fromList regs_out),
     non_pseudo_registers isa (fromList regs_feeding_address),
     fromList nias) in
  let regs_in =
    if isa.is_thread_start_instruction inst then
      Set.mapMaybe Function.id {
        Just isa.thread_start_info.tsi_addr;
        isa.thread_start_info.tsi_toc;
        isa.thread_start_info.tsi_extra;
      }
    else regs_in in
  let regs_out =
    if isa.is_thread_start_instruction inst then
      {isa.thread_start_info.tsi_return}
    else regs_out in
  let nias = match isa.isa_model with
    | MIPS ->
       match iprefix with
       | [] -> { NIA_successor }
       | prev_inst :: _ ->
          match prev_inst.mips_dia with
          | DIA_none -> {NIA_successor}
          | DIA_concrete_address a ->
             if prev_inst.finished then
               {NIA_concrete_address (mips_next_next_pc_of_finished_instruction isa prev_inst)}
             else
               {NIA_successor; NIA_concrete_address a}
          | DIA_register r ->
             if prev_inst.finished then
               {NIA_concrete_address(mips_next_next_pc_of_finished_instruction isa prev_inst)}
             else
               {NIA_successor ; NIA_indirect_address}
          end
       end
    | _ -> nias
    end in
  (ik, nias, dia, regs_in, regs_out, regs_feeding_address)


let starting_fetch_inst
      isa
      (new_ioid: ioid)
      (loc:      address)
    : instruction_instance 'i
  =
 <| instance_ioid =     new_ioid;
    instance_id_state = FreshIds.initial_id_state new_ioid;
    program_loc =       loc;
    program_opcode =    Nothing;
    instruction =       Unfetched;
    instruction_kind =  IK_simple;

    initial_micro_op_state =          MOS_not_fetched;
    initial_regs_in =                 Set.empty;
    initial_regs_out =                Set.empty;
    initial_regs_in_feeding_address = Set.empty;

    regs_in =                 Set.empty;
    regs_out =                Set.empty;
    regs_in_feeding_address = Set.empty;
    ioids_feeding_address =   Set.empty;
    nias =                    Set.empty;
    mips_dia = DIA_none;
    reg_reads =  [];
    reg_writes = [];

    subreads = initial_subreads; 
    subwrites = initial_subwrites;

    successful_atomic_store = Nothing;
    committed_barriers = [];
    finished = false;
    micro_op_state = MOS_not_fetched;
    rmw_finished_load_snapshot = Nothing;
|>

let starting_inst_instance_aux
      isa
      (new_ioid: ioid)
      (mop:      maybe opcode)
      (inst:     'i)
      (loc:      address)
      (ik, nias, dia, regs_in, regs_out, regs_feeding_address)
      ioids_feeding_address
      initial_outcome
    : instruction_instance 'i
  =
 <| instance_ioid =     new_ioid;
    instance_id_state = FreshIds.initial_id_state new_ioid;
    program_loc =       loc;
    program_opcode =    mop;
    instruction =       Fetched inst;
    instruction_kind =  ik;

    initial_micro_op_state =          MOS_plain initial_outcome;
    initial_regs_in =                 regs_in;
    initial_regs_out =                regs_out;
    initial_regs_in_feeding_address = regs_feeding_address;

    regs_in =                 regs_in;
    regs_out =                regs_out;
    regs_in_feeding_address = regs_feeding_address;
    ioids_feeding_address =   ioids_feeding_address;
    nias =                    nias;
    mips_dia = dia;
    reg_reads =  [];
    reg_writes = [];

    subreads = initial_subreads;
    subwrites = initial_subwrites;

    successful_atomic_store =
      match ik with
      | IK_mem_rmw (r, w) ->
          let () = ensure (is_atomic_read r = is_atomic_write w)
            "the atomicity of the read and the write of an RMW must be the same" in

          if isa.isa_model = RISCV then Nothing
          else if is_atomic_read r && is_atomic_write w then Just true
          else Nothing
      | IK_barrier _   -> Nothing
      | IK_mem_write _ -> Nothing
      | IK_mem_read _  -> Nothing
      | IK_branch      -> Nothing
      | IK_trans _     -> Nothing
      | IK_simple      -> Nothing
      | IK_cache_op _  -> Nothing
      end;

    committed_barriers =   [];

    finished =  false;

    micro_op_state = MOS_plain initial_outcome;

    rmw_finished_load_snapshot = Nothing;
|>



let starting_inst_instance
      isa
      (new_ioid: ioid)
      (mop:      maybe opcode)
      (inst:     'i)
      (loc:      address)
      (is:       list (instruction_instance 'i)) (* active prefix ++ old instructions *)
    : instruction_instance 'i
  =
  let initial_outcome = isa.instruction_semantics.initial_outcome_of_instruction inst in
  let (ik, nias, dia, regs_in, regs_out, regs_feeding_address) =
    analyse_instruction isa false [] initial_outcome inst is loc in
  let ioids_feeding_address = ioids_feeding_regs is regs_feeding_address in

  starting_inst_instance_aux isa new_ioid mop inst loc
    (ik, nias, dia, regs_in, regs_out, regs_feeding_address)
    ioids_feeding_address
    initial_outcome


let starting_fetch_exception_inst_instance
    (new_ioid: ioid)
    (fde:      fetch_and_decode_exception 'i)
    (loc:      address)
    : instruction_instance 'i
  =
 <| instance_ioid =     new_ioid;
    instance_id_state = FreshIds.initial_id_state new_ioid;
    program_loc =       loc;
    program_opcode =    Nothing;
    instruction =       Fetch_error;
    instruction_kind =  IK_simple;

    initial_micro_op_state =          MOS_pending_exception (ET_fetch_and_decode fde);
    initial_regs_in =                 {};
    initial_regs_out =                {};
    initial_regs_in_feeding_address = {};

    regs_in =                 {};
    regs_out =                {};
    regs_in_feeding_address = {};
    ioids_feeding_address =   {};
    nias =                    {};
    mips_dia =                DIA_none;
    reg_reads =  [];
    reg_writes = [];

    subreads = initial_subreads;
    subwrites = initial_subwrites;
    successful_atomic_store = Nothing;
    committed_barriers =   [];
    finished =  false;
    micro_op_state = MOS_pending_exception (ET_fetch_and_decode fde);
    rmw_finished_load_snapshot = Nothing;
|>

(* should be equal to starting_inst_instance m i.instance_ioid i.instruction i.program_loc ...activeprefix... *)
let restart_instruction (i: instruction_instance 'i) : instruction_instance 'i =
  let (tid, iid) = i.instance_ioid in
  let i_str = "(" ^ (show tid) ^ ":" ^ (show iid) ^ ") from 0x" ^ (show i.program_loc) in

  let () = ensure (not i.finished)
    $ "trying to restart a finished instruction " ^ i_str in
  let () = ensure (i.subwrites.sw_propagated_writes = [])
    $ "trying to restart instruction with propagated writes " ^ i_str in
  let () = ensure (i.committed_barriers = [])
    $ "trying to restart instruction with propagated barriers " ^ i_str in

  match i.rmw_finished_load_snapshot with
  | Nothing ->
      <| i with
          (* restarting the id state means read/write/barrier events will get the
          same id as before the restart. This allows for better hash-pruning
          and infinite loop detection. *)
          instance_id_state = FreshIds.initial_id_state i.instance_ioid;

          regs_in    = i.initial_regs_in;
          regs_out   = i.initial_regs_out;
          regs_in_feeding_address = i.initial_regs_in_feeding_address;
          reg_reads  = [];
          reg_writes = [];

          subreads = initial_subreads;
          subwrites = initial_subwrites;

          micro_op_state = i.initial_micro_op_state;

          (* committed_barriers   = []; *)
          (* finished             = false; *)
      |>
      (* TODO: for a restarted lswx, we need to also reset regs_in etc.*)
  | Just snapshot ->
      <| i with
          instance_id_state = snapshot.rfls_instance_id_state;
          reg_reads  = snapshot.rfls_reg_reads;
          reg_writes = snapshot.rfls_reg_writes;
          subwrites = initial_subwrites;
          micro_op_state = snapshot.rfls_micro_op_state;
      |>
  end


(* recalculate_register_footprint, used for instructions whose register footprint changes based on the value of a register read *)
let recalculate_register_footprint isa
    (i:  instruction_instance 'i)
    (old_outcome: outcome unit)
    (is: list (instruction_instance 'i))
    : instruction_instance 'i
  =
  let instr = ensure_fetched (i.instruction) in

  let env = List.map (fun (name,_,v) -> (name,v)) i.reg_reads in

  let (_, _, _, regs_in, regs_out, regs_feeding_address) =
    analyse_instruction isa true env old_outcome instr is i.program_loc in

  let is_pseudo_register' = is_pseudo_register isa in
  <| i with regs_in = regs_in union { r | forall ((r,rrs,v) MEM i.reg_reads) | not (is_pseudo_register' r)};
            regs_out = regs_out union { r | forall ((r,(_,v)) MEM i.reg_writes) | not (is_pseudo_register' r)};
            regs_in_feeding_address = regs_feeding_address;
 (* TODO: does that also need to be extended with those already read from? *)
            ioids_feeding_address = ioids_feeding_regs is regs_feeding_address |>


let recalculate_ioids_feeding_address
    (prefix:     list (instruction_instance 'i))
    (it :        instruction_tree 'i)
    : instruction_tree 'i
  =
  instruction_tree_map
    (fun prefix' i' _ ->
      <| i' with ioids_feeding_address = ioids_feeding_regs prefix' i'.regs_in_feeding_address |>
    )
    prefix
    it


let nias_of_instruction
    params
    (isa:    isa 'i)
    (state:  thread_state 'i)
    (iic:    instruction_in_context 'i)
    : set address
  =
  match iic.iic_instance.micro_op_state with
  | MOS_plain (O_Done ()) ->
      { next_address_of_finished_instruction isa iic.iic_instance }
  | _ ->
      Set.bigunionMap
        (function
        | NIA_successor -> { successor_fetch_address iic.iic_instance }
        | NIA_concrete_address a -> { a }
        | NIA_indirect_address ->
            match List.lookup isa.nia_reg iic.iic_instance.reg_writes with
            | Just (_, rv) ->
                let al = ensure_just (address_lifted_of_register_value rv)
                                    "NIA/PC register write not 64 bits" in
                ensure_just (address_of_address_lifted al) "NIA/PC not a concrete address"
                $> Set.singleton
            | Nothing ->
                let branch_targets = Map.findWithDefault state.thread Map.empty params.branch_targets in
                Map.findWithDefault iic.iic_instance.program_loc {} branch_targets
            end
        end)
        iic.iic_instance.nias
  end

let potential_next_addresses_of_instruction
    (params: thread_params)
    (isa:    isa 'i)
    (state:  thread_state 'i)
    (iic:    instruction_in_context 'i)
    : set address
  =
  if isa.isa_model = MIPS then
    (* Maybe the instruction preceding this one was a branch? *)
    match iic.active_prefix with
    | [] ->
       (* no previous instruction, ergo not a branch delay XXX unless likely...  *)
       { successor_fetch_address iic.iic_instance }
    | prev_inst :: _ ->
       if prev_inst.finished && is_branch_instruction (ik prev_inst) then
         let () = ensure (not (is_branch_instruction (ik iic.iic_instance)))
              "undefined behaviour: branch in branch delay slot" in (* XXX could be likely... *)

         (* Use nextNextPC of finished instruction (may be branch delay) *)
         { mips_next_next_pc_of_finished_instruction isa prev_inst }
       else
         (* Use NIAs *)
         nias_of_instruction params isa state iic
    end
  else
    if iic.iic_instance.finished then
      { next_address_of_finished_instruction isa iic.iic_instance }
    else
      nias_of_instruction params isa state iic


let rec make_old_instructions_helper
    (isa :                       isa 'i)
    (state:                      thread_state 'i)
    (unacknowledged_syncs_ioids: set ioid)
    (((T iis) as it):            instruction_tree 'i)
    (acc:                        list (instruction_instance 'i))
    : list (instruction_instance 'i) * instruction_tree 'i
  =
  match iis with
  | [(i, T it')] ->

      if i.finished && i.instance_ioid NIN unacknowledged_syncs_ioids then
        let succs = [instruction.program_loc | forall ((instruction, _) MEM it') | true] in
        let nia =
          if isa.isa_model = MIPS then
            match acc with
            | [] ->  successor_fetch_address i
            | prev_inst :: _ ->
                mips_next_next_pc_of_finished_instruction isa prev_inst
            end
          else
            next_address_of_finished_instruction isa i
        in
        if (nia = state.return_address || List.elem nia succs) then
          (* DEBUG:
          let () =
            let (name, _, _) = i.instruction in
            print_string ("\nmove " ^ name ^ " to old_instructions (") in
          let () = print_integer (integerFromNat i.instance_ioid) in
          let () = print_endline ")" in
          *)
          make_old_instructions_helper isa state unacknowledged_syncs_ioids (T it') (i :: acc)
        else (acc,it)
     else (acc,it)
  | _ -> (acc,it)
  end

(* return a new thread state with as many instructions as possible moved from
   the instruction tree to the list of old instructions *)
let make_old_instructions isa (state: thread_state 'i) : thread_state 'i =
  match isa.isa_model with
  | MIPS -> state (* optimisation not yet implemented for MIPS due to branch delays *)
  | _ ->
  let unacknowledged_syncs =
    match state.thread_substate with
    | PLDI11_thread pldi11_thread -> pldi11_thread.unacknowledged_syncs
    | POP_thread _                -> {}
    | TSO_thread                  -> {}
    end
  in
  let unacknowledged_syncs_ioids = {b.b_ioid | forall (b IN unacknowledged_syncs) | true} in
  let (old_instrs, it) =
    make_old_instructions_helper isa state unacknowledged_syncs_ioids state.instruction_tree []
  in
  <| state with
     old_instructions = old_instrs ++ state.old_instructions;
     instruction_tree = it;
  |>
  end

let thread_is_final_state thread_state = thread_state.instruction_tree = T []

(** Other *******************************************)

let rec find_propagated_writes (T iits: instruction_tree 'i) (acc: list write) : list write =
  match iits with
  (* NOTE: there will not be propagated writes after a branch, hence we
     stop the search when the tree starts branching *)
  | (instruction, it) :: [] ->
     find_propagated_writes it (acc ++ instruction.subwrites.sw_propagated_writes)
  | _ -> acc
  end

let write_was_subsumed params iic write = 
  params.thread_allow_write_subsumption &&
    let propagated_writes = find_propagated_writes iic.subtree [] in
    exists (w MEM propagated_writes). non_empty_intersection write.w_addr w.w_addr

let propagated_write_slices_of_instruction i = 
  complete_writes i.subwrites.sw_propagated_writes


(* reduce (write, slices) to the part that is not "overwritten/hidden
   behind" wss *)
let parts_of_write_not_overwritten_by_write_slices
      (wss : write_slices)
      ((write, slices) : write * slices) 
  : maybe (write * slices) = 
  let (_, match_write_slices) =
    match_writes write.w_addr slices
      (wss ++ [(write, slices)]) [] in
  match List.lookup write match_write_slices with
  | Nothing -> Nothing
  | Just slices -> Just (write, slices)
  end
   
let parts_of_read_rf_not_overwritten_by_write
      writes_read_from read_request write_instr = 
  let propagated_writes =
    complete_writes (propagated_writes_of_inst write_instr) in
  let (_, writes_read_from) =
    match_writes read_request.r_addr [complete_slice read_request.r_addr]
      (propagated_writes ++ writes_read_from) [] in
  [(w, s) | forall ((w, s) MEM writes_read_from)
   | not (List.elem w write_instr.subwrites.sw_propagated_writes)]

let parts_of_read_rf_not_forwarded_from_write
  writes_read_from _read_request write_instr = 
  [(w, s) | forall ((w, s) MEM writes_read_from)
          | not (List.elem w write_instr.subwrites.sw_potential_writes)]





let writes_read_from (inst: instruction_instance 'i) : list (write * slices) =
  List.concat (snd (List.unzip inst.subreads.sr_writes_read_from))


let machine_update_initial_register_state t updates = 
  let function_update x v f = fun x' -> if x = x' then v else f x' in
  let reg_state = List.foldl (fun acc (x,y) -> function_update x y acc)
                             t.initial_register_state updates in
  <| t with initial_register_state = reg_state |>

let machine_update_initial_fetch_address t addr =
  <| t with initial_fetch_address = Just addr |>


(** Thread-subsystem-independent functions ...................................*)

val ts_instructions : forall 'i 'ts. threadSubsystem 'i 'ts -> 'ts -> set (instruction_instance 'i)
let ts_instructions tmodel ts = 
  let (linear_prefix,instruction_tree) = tmodel.ts_instruction_tree ts in
  (Set.fromList linear_prefix) union (instructions_of_tree instruction_tree)
  

val ts_find_instruction : forall 'i 'ts. threadSubsystem 'i 'ts -> 
                          (list (instruction_instance 'i) -> instruction_instance 'i -> bool) -> 'ts ->
                          maybe (list (instruction_instance 'i) * instruction_instance 'i)

let ts_find_instruction tmodel p ts =
  let (old_instructions,instruction_tree) = tmodel.ts_instruction_tree ts in
  match
    tree_of_old_and_new_instructions_helper instruction_tree old_instructions
    $> instruction_tree_find (fun prefix i _ -> p prefix i) []
  with
  | Just (prfx,i,_) -> Just (prfx,i)
  | _ -> Nothing
  end

val ts_branch_targets :
  forall 'i 'ts.
  thread_params ->
  threadSubsystem 'i 'ts ->
  'ts ->
  map address (set address)
let ts_branch_targets params tmodel state  =
  let (old_instructions,instruction_tree) = tmodel.ts_instruction_tree state in
  tree_of_old_and_new_instructions_helper instruction_tree old_instructions
  $> instruction_tree_fold_root
    (fun acc _ i (T its) ->
      if exists (nia IN i.nias). nia = NIA_indirect_address ||
         (params.thread_fetch_order = Fetch_Unrestricted)  then
          match its with
          | [] ->
              acc union {(i.program_loc, tmodel.ts_return_address state)}
          | _ ->
              acc union {(i.program_loc, i'.program_loc) | forall ((i', _) MEM its) | true}
          end
      else acc)
    {}
    []
  $> Set.bigunion
  $> Set_extra.toList
  $> List.foldl (fun bts (l, l') ->
    Map.insert l ((Map.findWithDefault l {} bts) union {l'}) bts
  ) Map.empty


(* returns '(rfps, wfps)' where rfps is the set of read footprints and
wfps is the set of write footprints *)
val ts_memory_footprints : forall 'i 'ts. threadSubsystem 'i 'ts -> 'ts -> (set footprint) * (set footprint)
let ts_memory_footprints tmodel state =
  let (old_instructions, instruction_tree) = tmodel.ts_instruction_tree state in
  let accs =
    tree_of_old_and_new_instructions_helper instruction_tree old_instructions
    $> instruction_tree_fold_root
      (fun (racc, wacc) _ i _ ->
          ( match i.subreads.sr_addr with
            | Nothing -> racc
            | Just r  -> racc union {r}
            end,
            match i.subwrites.sw_addr with
            | Nothing -> wacc
            | Just w  -> wacc union {w}
            end))
      ({}, {})
      []
  in
  (Set.map fst accs $> Set.bigunion, Set.map snd accs $> Set.bigunion)



(** auxiliary functions to construct transitions *********************************)


let make_thread_cont_res
    (restarted: set ioid)
    (discarded: set ioid)
    (state:     'ts)
    : thread_cont_res 'ts
  =
  <|  tcr_state          = state;
      tcr_inst_restarted = restarted;
      tcr_inst_discarded = discarded;
  |>

let make_cont tid ioid
    (cont: 'answer -> thread_cont_res 'ts)
    : thread_cont 'answer 'ts
  =
  <|  tc_tid  = tid;
      tc_ioid = ioid;
      tc_cont = cont;
  |>

let make_label' (tid : thread_id) (ioid : ioid)
    (label:  'request)
    (state': 'answer -> thread_cont_res 'ts)
    : thread_label 'request 'answer 'ts
  =
  <|  tl_label = label;
      tl_suppl = Nothing;
      tl_cont  = make_cont tid ioid state'
  |>

let make_label state iic
    (label:  'request)
    (state': 'answer -> thread_cont_res 'ts)
    : thread_label 'request 'answer 'ts
  =
  make_label' state.thread iic.iic_instance.instance_ioid label state'



(** Make events *)

let make_read_request_events_ii isa tid iic_instance footprint read_kind = 
  let (read_requests, id_state') = 
    isa.make_read_request_events
      tid 
      (ensure_fetched iic_instance.instruction)
      iic_instance.instance_id_state
      iic_instance.instance_ioid
      footprint
      read_kind
  in
  let iic_instance' = <| iic_instance with instance_id_state = id_state' |> in
  (read_requests, iic_instance')

(* used to enforce atomicity in SC model *)
let make_single_atomic_read_request_event_ii _isa tid iic_instance (addr,size) rk =
  let (read_requests, id_state') = 
    Events.make_read_request_events'
      iic_instance.instance_id_state
      tid iic_instance.instance_ioid addr size size rk
  in
  let iic_instance' = <| iic_instance with instance_id_state = id_state' |> in
  (read_requests, iic_instance')



let make_empty_write_events_ii isa tid iic_instance footprint write_kind = 
  let (write_requests, id_state') = 
    isa.make_empty_write_events
      tid
      (ensure_fetched iic_instance.instruction)
      iic_instance.instance_id_state
      iic_instance.instance_ioid
      footprint
      write_kind
  in
  let iic_instance' = <| iic_instance with instance_id_state = id_state' |> in
  (write_requests, iic_instance')

let make_single_atomic_empty_write_event_ii _isa thread i (address, size) write_kind = 
  let (write_requests, id_state') = 
    Events.make_empty_write_events'
      i.instance_id_state thread i.instance_ioid address size size write_kind
  in
  let i' = <| i with instance_id_state = id_state' |> in
  (write_requests, i')


let make_barrier_event_ii i tid bk = 
  let (b, id_state') = 
    Events.make_barrier_event i.instance_id_state tid i.instance_ioid bk in
  let i' = <| i with instance_id_state = id_state' |> in
  (b, i')




(** Make the UI state *)

let make_ui_machine_thread_state (_s : 'storage_subsystem_state) 
      (t : maybe (thread_state 'i)) (t' : thread_state 'i)
      (ncands: list (ui_trans 'i 'ts 'ss)) : (ui_thread_state 'i 'ts 'ss) =

  (* UI_machine_thread_state *)
    <| ui_thread = t'.thread ;           
       ui_register_data = t'.register_data;
       ui_initial_register_state = t'.initial_register_state;
       ui_initial_fetch_address =
         match t with
         | Just t ->
            if t.initial_fetch_address = t'.initial_fetch_address
            then C2b_unchanged t.initial_fetch_address
            else C2b_changed t'.initial_fetch_address
         | Nothing ->
            unchanged2b t'.initial_fetch_address
         end ;
       ui_instruction_tree =
         match t with
         | Just t ->
            make_ui_instruction_tree
              (tree_of_old_and_new_instructions t)
              (tree_of_old_and_new_instructions t') ncands
         | Nothing ->
            make_ui_instruction_tree_nocompare
              (tree_of_old_and_new_instructions t') ncands
         end;
       
       ui_unacknowledged_syncs =
         match t with
         | Just t -> 
            match (t.thread_substate, t'.thread_substate) with
            | (PLDI11_thread thread, PLDI11_thread thread') ->
               Just (ui_set_diff3 thread.unacknowledged_syncs thread'.unacknowledged_syncs)
            | _ -> Nothing
           end
         | Nothing ->
            match t'.thread_substate with
            | PLDI11_thread thread' ->
               Just (unchanged3_set thread'.unacknowledged_syncs)
            | _ -> Nothing
            end
         end;

       ui_read_issuing_order =
         match t with 
         | Just t ->
            match (t.thread_substate, t'.thread_substate) with
            | (POP_thread substate, POP_thread substate') ->
               Just (ui_set_diff3 substate.read_issuing_order.relon_rel
                       substate'.read_issuing_order.relon_rel)
            | _ -> Nothing
            end
         | Nothing ->
            match t'.thread_substate with
            | POP_thread substate' ->
               Just (unchanged3_set substate'.read_issuing_order.relon_rel)
            | _ -> Nothing
            end
         end;

       ui_initial_fetch_transitions = 
         List.filter
           (fun (n,tr) ->
             match tr with
             | T_trans (T_sync (T_fetch tl) _) -> tl.tl_cont.tc_tid = t'.thread
             | _ -> false
            end
           )
           ncands;
     |>
